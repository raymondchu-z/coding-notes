# 目录

[TOC]



# 重点代码

参考链接：

[GitHub - CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计](https://github.com/CyC2018/CS-Notes)

#### 调用sort时自己写cmp的格式

1. 按区间右边界排序

~~~c++
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
~~~



#### [二分查找](#二分查找)

**找最右位置，要注意判断`lo-1`是否越界**

```c++
int binSearch(vector<int> & nums, int target, int lo, int hi){//0 <= lo < hi <= size
    while(lo < hi){
        int mi = lo + (hi-lo)/2;
        target <  nums[mi] ? hi = mi : lo = mi + 1;//[lo,mi)or(mi,hi)
    }//出口时 lo == hi
    return lo - 1
}
```

**找最左位置呢？**区别就在于，`target =  nums[mi]`时往左还是往右。

~~~c++
int binSearch(vector<int> & nums, int target, int lo, int hi){//0 <= lo < hi <= size
    while(lo < hi){
        int mi = lo + (hi-lo)/2;
        target <=  nums[mi] ? hi = mi : lo = mi + 1;//[lo,mi)or(mi,hi)
    }//出口时 lo == hi
    return lo - 1
}
~~~



#### 遍历map

~~~cpp
for(auto& [key, value] : map){}
~~~

#### 链表与二叉树节点定义

~~~c++

/** * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

/*
 * Definition for singly-linked list. 
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
~~~





# 机试技巧

[C++做题小技巧 - 百度文库 (baidu.com)](https://wenku.baidu.com/view/92f4cb4978563c1ec5da50e2524de518964bd3c3.html)

[ACM/OI中C++常用优化(实用/调试/技巧)代码(语法)_无限迭代中......-CSDN博客](https://blog.csdn.net/weixin_43272781/article/details/90726422)

[ACM、C++关于输入输出的小技巧 | 大专栏 (dazhuanlan.com)](https://www.dazhuanlan.com/2020/03/20/5e73a2931ed63/)

[ACM常用的一些技巧_Cheney_渣渣杰 的博客-CSDN博客](https://blog.csdn.net/cj151525/article/details/89407326)

[C++ STL容器 常用API](https://blog.csdn.net/weixin_43150428/article/details/82469933)

http://www.cplusplus.com/reference/stl/

1. C++万能编译头文件

~~~
#include<bits/stdc++.h>
~~~

2. cin和cout取消同步

~~~
#include <iostream>
using namespace std;
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // IO
}
~~~

3. 在没有必要刷新输出流的时候应尽量使用cout << ‘\n’, 过多的endl是影响程序执行效率低下的因素之一.

4. 十三、奇偶判断

   ~~~
   n%2
   n&1
   ~~~

   其中&1的效率高于%2

5. 预处理宏

   ~~~
   #define long long ll
   ~~~

6. 右移会比除快很多

   ~~~
   n/2
   n>>1
   ~~~

7. 2的幂判断

   ~~~
   x > 0 ? ( x & (x - 1)) == 0 : false
   ~~~

8. 加法优化
   用++i代替i++，后置++需要保存临时变量以返回之前的值，在 STL 中非常慢。

9. 输出空格分隔、末尾无空格的数组

   ~~~
   for(int i=1;i<=n;i++){
       printf("%d%c",a[i]," \n"[i==n]);
   }
   ~~~

10. 常用C++库函数 （STL）

    | 函数               | 作用                            |
    | ------------------ | ------------------------------- |
    | sort               | 排序                            |
    | memset             | 赋值                            |
    | next_permutation   | 全排列                          |
    | max                | 最大值                          |
    | min                | 最小值                          |
    | swap               | 交换                            |
    | exit               | 退出程序                        |
    | __builtin_popcount | 一个数的二进制表示中有多少位是1 |
    | strlen             | 字符数组长度                    |

11. 非零即真

    ~~~
    if(x)
    ~~~

12. 输出浮点数

    ~~~
    printf("%f %d\n", a, b);
    ~~~

    

# 算法专题

每道题的记录模板如下：

> 题目描述：
>
> 直接思路：
>
> 优化思路：
>
> ~~~c++
> 
> ~~~
>
> 知识点：

## 动态规划

递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

该问题是否能用动态规划解决，**取决于这些”小问题“会不会被被重复调用。**

第 1 步：状态定义。

第 2 步：推导状态转移方程。

第 3 步：初始化。

第 4 步：输出。

### 斐波那契数列

#### [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

70\. Climbing Stairs (Easy)

 [力扣](https://leetcode-cn.com/problems/climbing-stairs/description/)

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

直接思路：定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14fe1e71-8518-458f-a220-116003061a83.png" width="200px"> </div><br>

优化思路：考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

~~~c++
class Solution {
public:
    int climbStairs(int n) {
        if(n <=2 ) return n;
        int pre2 = 1, pre1 = 2;//pre2->pre1->cur
        for(int i = 2; i < n; i++){
            int cur = pre1 + pre2;
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;//因为每次走完，会把cur传给pre1，而cur是个局部变量。
    }
};
~~~

知识点：

* 根据转移方程来确定能否优化dp数组为O(1).

#### [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

198\. House Robber (Easy)

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。

直接思路：定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。

由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg" width="350px"> </div><br>

优化思路：考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

~~~c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int pre2 = 0, pre1 = 0;//pre2->pre1->curr
        for(int i = 0; i < nums.size(); i++){
            int curr = max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = curr;
        }
        return pre1;
    }
};
~~~

知识点：和上一题不同的是，pre1和pre2并没有一个初始值，一切结果都是根据nums来的。

#### [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

题目描述：在环形街区打家劫舍

直接思路：跟打家劫舍相比，要注意边界条件。也就是第一个和最后一个不能同时打劫（也可以同时不打劫，根据题目规则判断）。

优化思路：

~~~c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];
        return max(rob(nums, 0, n-2), rob(nums, 1, n-1));
    }
    int rob(vector<int>& nums, int begin, int end){//函数重载：参数列表不同
        int pre2 = 0, pre1 = 0;//pre2->pre1->curr
        for(int i = begin; i <= end; i++){
            int curr = max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = curr;
        }
        return pre1;
    }
};
~~~

知识点：

* 在C++中同名函数有三种关系：
  - 重载（overlode）：相同作用域；函数名相同；参数列表不同（参数类型不同，或者参数个数不同，或者参数个数和参数类型都不相同）；返回类型随意。
  - 覆盖（override）：不同作用域下（分别在父类和子类中）；函数名相同；参数列表列表相同；返回类型相同（协变除外）；基类函数必须有virtual修饰；父类和子类的访问限定可以不同。
  - 隐藏（overhide）：不同作用域下（分别在父类和子类中）；函数名相同；除过覆盖的同名函数都是隐藏关系。

### 矩阵路径

#### [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。

直接思路：[剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)。每一格能从上边或左边走过来。一般情况：`dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];`。考虑边界情况，`当 i>0且j=0 时，dp[i][0]=dp[i−1][0]+grid[i][0]`,`当 i=0且j>0 时，dp[0][j]=dp[0][j-1]+grid[0][j]`

优化思路：每次只存储上一行的 dp 值，则可以将空间复杂度优化到 O(n)。dp数组的前j个数字是f(i,0)~f(i, j-1)【这一行的结果】,然后是f(i-1,j)~f(i-1,n-1)【上一行的结果】

~~~c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int r = grid.size(), c = grid[0].size();
        vector<int> dp(c+1, 0);//dp数组记录上一行的最大价值，首元素为0
        //dp数组的前j个数字是f(i,0)~f(i, j-1),然后是f(i-1,j)~f(i-1,n-1)
        for(int i=0; i < r; i++){
            for(int j=0; j < c; j++){
                //dp[j]=f(i, j),dp[j+1]=f(i-1,j+1)
                if(i == 0){//第一行只能从左边来
                    dp[j+1] = dp[j] + grid[i][j];
                }
                else if(j == 0){//第一列只能从上边来
                    dp[j+1] = dp[j+1] + grid[i][j];
                }
                else{
                    dp[j+1] = min(dp[j],dp[j+1]) + grid[i][j];
                }
            }
        }
        return dp[c];
    }
};
~~~

知识点：

- 如果每一格都只能从上或左两个方向得到，那么dp矩阵可以优化为dp数组，dp数组的前j个数字是f(i,0)~f(i, j-1)【这一行的结果】,然后是f(i-1,j)~f(i-1,n-1)【上一行的结果】。

#### [不同路径](https://leetcode-cn.com/problems/unique-paths/)

题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。

直接思路：

1. 这是个排列组合题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。

   ![image-20201215201211962](https://gitee.com/Raymond-Z/typora/raw/master/image/20201215201214.png)

2. 用动态规划方法，`dp[i][j] = dp[i - 1][j], dp[i][j - 1];`

优化思路：

2. 同样可以优化成用一维数组。`dp[j] = dp[j] + dp[j - 1];`

~~~c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int S = m + n - 2;  // 总共的移动次数
        int D = m - 1;      // 向下的移动次数
        long ret = 1;
        for (int i = 1; i <= D; i++) {
            ret = ret * (S - D + i) / i;
        }
        return (int)ret;
    }
};

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[j] = dp[j] + dp[j-1];
            }
        }
        return dp[n-1];
    }
};
~~~

知识点：

- 可以用变量定义数组长度，但不可同时初始化。

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

描述：在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

思路：暴力法：dfs，遍历每一个格子作为起点。可以做剪枝：当最大边长大于当前起点的列或行。每个起点分别从size为1开始增长，但是这里会有很多重复的判断，需要dp。

dp法：dp法，`dp[i][j]`表示以(i,j)作为右下角，存在的最大正方形的边长。转移方程与左，上，左上均有关。

~~~c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        //dp法，dp[i][j]表示以(i,j)作为右下角，存在的最大正方形的边长
        //dp[i][j] = 0 if matrix[i][j] == 0
        //dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        int max_edge = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(matrix[i][j] == '1'){
                    if(i == 0 || j == 0){
                        dp[i][j] = 1;
                    }
                    else{
                        dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1]))+1;
                    }
                    max_edge = max(max_edge, dp[i][j]);
                }
            }
        }
        return max_edge*max_edge;
    }
};
~~~



### 数组区间

#### [区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

题目描述：给定一个整数数组  `nums`，求出数组从索引 `i` 到 `j`（`i ≤ j`）范围内元素的总和，包含 `i`、`j `两点。

直接思路：每次都计算一遍sum。

优化思路：求区间 i \~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 \~ i - 1 的和。

~~~c++
class NumArray {
public:
    vector<int> sum;
    NumArray(vector<int>& nums) {
        if(nums.empty()) return;
        sum.push_back(0);
        for(int i=0; i < nums.size(); i++){
            sum.push_back(sum.back() + nums[i]);//sum[i]是[0,i-1]的和
        }
    }
    int sumRange(int i, int j) {
        if(sum.empty()) return 0;
        return sum[j+1] - sum[i];
    }
};
~~~

知识点：

#### [数组中等差递增子区间的个数](https://leetcode-cn.com/problems/arithmetic-slices/)

题目描述：

~~~
A = [0, 1, 2, 3, 4]

return: 6, for 3 arithmetic slices in A:

[0, 1, 2],
[1, 2, 3],
[0, 1, 2, 3],
[0, 1, 2, 3, 4],
[ 1, 2, 3, 4],
[2, 3, 4]
~~~



直接思路：滑动窗口？窗口长度为3，依次向后判断，如果是等差数列则扩大窗口，直到失败。然后长度缩小为3，继续下一个判断。这样有很多冗余。

优化思路：dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。

当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。

```html
dp[2] = 1
    [0, 1, 2]
dp[3] = dp[2] + 1 = 2
    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3
    [1, 2, 3]     // 新的递增子区间
dp[4] = dp[3] + 1 = 3
    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4
    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4
    [2, 3, 4]        // 新的递增子区间
```

综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。

因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。

~~~c++
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& A) {
        if(A.empty()) return 0;
        vector<int> dp(A.size());
        for(int i = 2; i < A.size(); i++){
            if(A[i] - A[i-1] == A[i-1] - A[i-2]){
                dp[i] = dp[i-1] + 1;
            }
        }
        int total = 0;
        for(int cut : dp){
            total += cut;
        }
        return total;
    }
};
~~~

知识点：

* 以后dp都直接用vector。用int数组的话，比较麻烦。一是因为int数组不会初始化为0，二是因为int数组不能使用变量定义大小的同时初始化。

### 分割整数

#### [分割整数的最大乘积](https://leetcode-cn.com/problems/integer-break/description/)

题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).

直接思路：好像以前做过，[剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)。已经证明，用贪心法只要多取3就可以。

令`dp[i]`表示整数i对应的最大乘积，那么`dp[i]`的值应是`dp[j]*(i-j)`(`j`属于`[1,i-1]`)的最大值，同时注意`dp[i]`中对应的值是经过拆分了的，所以还应判断两个数拆分的情况，即`j*(i-j)`的值，取最大即可。即：`dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));`

~~~c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i-1; j++){
                dp[i] = max(max(dp[i], dp[j]*(i-j)), j*(i-j));
            }
        }
        return dp[n];
    }
};
~~~

知识点：为啥`dp[i] = max(j * dp[i - j], j * (i - j));`不行呢？因为小于3是，拆分了更小。

#### [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

题目描述：给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

直接思路：dp数组里存的是完全平方数的个数，方程中`dp[i-j*j]+1`的jxj从`1,4,9,16……`中取值，如果n能分解成jxj+某个数k，而这个k同样这样分解，则能得到结果。

~~~c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1);
        dp[0] = 0;
        for(int i=1; i <= n; i++){
            int minValue = INT_MAX;
            for(int j=1; i >= j*j; j++){
                minValue = min(minValue, dp[i-j*j]+1);
            }
            dp[i] = minValue;
        }
        return dp[n];
    }
};
~~~

#### [分割整数构成字母字符串](https://leetcode-cn.com/problems/decode-ways/)

题目描述：Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

直接思路：[剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)，输入是int，这里输入是string。当时写的是贪心。

dp数组含义是，s[0~i]解码方法总数。

因为有特殊情况，需要分情况讨论：
s[i]=0，若s[i-1]=1或s[i-1]=2，dp[i]=dp[i-2]，即这两个数字被唯一译码；其他情况return 0，译码失败。
s[i]!=0，s[i-1]=1，s[i-1]与s[i]分开译码，为dp[i-1]：合并译码，为dp[i-2]；即dp[i]= dp[i-1]+ dp[i-2]
s[i]!=0，s[i-1]=1&&s[i]<=6&&s[i]>=1，同上

优化思路：dp[i]只与dp[i-1]和dp[i-2]有关，可以优化空间。

~~~c++
class Solution {
public:
    int numDecodings(string s) {
        if(s[0] == '0') return 0;//前导0
        int pre2 = 1, pre1 = 1;//pre2->pre1->curr
        for(int i=1; i < s.size(); i++){
            int curr = pre1;//要赋初值，避免直接pre1 = curr（即27）
            if(s[i] == '0'){
                if(s[i-1] == '1' || s[i-1] == '2'){
                    curr = pre2;
                }
                else return 0;
            }
            else if(s[i-1] == '1' || (s[i-1] == '2' && s[i] >= '1' && s[i] <= '6')){
                curr = pre2 + pre1;
            }
            pre2 = pre1;
            pre1 = curr;
        }
        return pre1;
    }
};
~~~

### 最长递增子序列

已知一个序列 {S<sub>1</sub>, S<sub>2</sub>,...,S<sub>n</sub>}，取出若干数组成新的序列 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个  **子序列**  。

如果在子序列中，当下标 ix > iy 时，S<sub>ix</sub> > S<sub>iy</sub>，称子序列为原序列的一个  **递增子序列**  。

定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 S<sub>n</sub> 结尾的序列的最长递增子序列长度。对于一个递增子序列 {S<sub>i1</sub>, S<sub>i2</sub>,...,S<sub>im</sub>}，如果 im < n 并且 S<sub>im</sub> < S<sub>n</sub>，此时 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>, S<sub>n</sub>} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 S<sub>n</sub> 就构成了以 S<sub>n</sub> 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | S<sub>i</sub> < S<sub>n</sub> && i < n} 。

因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {S<sub>n</sub>} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ee994da4-0fc7-443d-ac56-c08caf00a204.jpg" width="350px"> </div><br>

#### [最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

明确题目中的条件：

- 子序列：不要求连续子序列，只要保证元素前后顺序一致即可；
- 上升：这里的「上升」是「严格上升」，例如： `[2, 3, 3, 6, 7]` 这样的子序列是不符合要求的。

思路：

第 1 步：状态定义。`dp[i]` 表示以 `nums[i]` 结尾的最长上升子序列的长度。即：在 `[0, ..., i]` 的范围内，选择以数字 `nums[i]` 结尾可以获得的最长上升子序列的长度。

说明：以 `nums[i]` 结尾，是子序列动态规划问题的经典设计状态思路，思想是动态规划的无后效性（定义得越具体，状态转移方程越好推导）。

第 2 步：推导状态转移方程：遍历到 `nums[i]` 的时候，我们应该把下标区间 `[0, ... ,i - 1]` 的 `dp` 值都看一遍，如果当前的数 `nums[i]` 大于之前的某个数，那么 `nums[i]` 就可以接在这个数后面形成一个更长的上升子序列。把前面的数都看了， `dp[i]` 就是它们的最大值加 1。即比当前数要小的那些里头，找最大的，然后加1。

状态转移方程即：`dp[i] = max(1 + dp[j] if j < i and nums[j] < nums[i])`。

第 3 步：初始化。单独一个数是子序列，初始化的值为 1；

第 4 步：输出。应该扫描这个 `dp` 数组，其中最大值的就是题目要求的最长上升子序列的长度

~~~c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        int res = dp[0];
        for(int i=0; i<n; i++){
            for(int j=0; j<i; j++){
                if(nums[j] < nums[i])
                    dp[i] = max(dp[i], dp[j]+1);
            }
            res = max(res, dp[i]);//每次记录dp[i]时记录最大值，就不用再遍历一遍dp数组。
        }
        return res;
    }
};
~~~

以上的时间复杂度为 O(N<sup>2</sup>)，可以使用二分查找将时间复杂度降低为 O(NlogN)。

具体的，用二分查找替代掉第二次循环，即在区间 `[0, ... ,i - 1]`的dp中找最大值。

两种二分经典写法（要默写）

~~~c++
    int binSearch(vector<int> & nums, int target, int lo, int hi){//0 <= lo < hi <= size
        while(1 < hi - lo){//有效查找区间为1时，算法终止
            int mi = (lo + hi) >> 1;
            target <  nums[mi] ? hi = mi : lo = mi;

        }//出口时 hi=lo+1
        return target == nums[lo] ? lo : -1;
    }
~~~

~~~c++
int binarySearchvector<int> & nums, int target, int lo, int hi) {
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;//如果找不到呢？
}
~~~

代码：

~~~c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> tails(n);
        int len = 0;
        for(int num : nums){
            int index = binarySearch(tails, num, 0, len);
            tails[index] = num;
            if(index == len)
                len++;
        }
        return len;
    }
    
    int binarySearch(vector<int>& tails, int target, int lo, int hi){//0<= lo < hi <= size 
        while(lo < hi){
            int mid = lo + (hi - lo) / 2;
            if(tails[mid] == target)
                return mid;
            else if (tails[mid] > target)
                hi = mid;
            else   
                lo = mid + 1;
        }
        return lo;
    }
};
~~~

知识点： 时间复杂度为O(N<sup>2</sup>)的动态规划，可以考虑使用二分查找代替内层循环将时间复杂度降低为 O(NlogN)。

#### [一组整数对能够构成的最长链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)

题目描述：对于 (a, b) 和 (c, d) ，如果 b \< c，则它们可以构成一条链。

```html
Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]
```

直接思路：排序（数对(a,b)按a排序）后，定义dp[i]为以pairs[i]结尾时的最长链长度。当 `j < i` 且 `pairs[j][1] < pairs[i][0]` 时，扩展数对链，更新 `dp[i] = max(dp[i], dp[j] + 1)`。

~~~c++
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end());
        int n = pairs.size();
        vector<int> dp(n, 1);
        int res = 1;
        for(int i=0; i<n; i++){
            for(int j=0; j<i; j++){
                if(pairs[j][1] < pairs[i][0])
                    dp[i] = max(dp[i], dp[j]+1);
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
~~~

优化思路：将内层循环用二分查找代替，时间复杂度降低为 O(NlogN)。

~~~c++
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(),pairs.end(),cmp);
        int n = pairs.size();
        vector<vector<int>> chain;
        for(auto & p : pairs){
            int index = binarySearch(chain, p[0], 0, chain.size());
            if(index >= chain.size()){//
                chain.emplace_back(p);
            }
            else if(chain[index][1] > p[1]){//替换
                chain[index] = p;
            }
        }
        return chain.size();

    }
    
    static bool cmp(vector<int>& a,vector<int>& b){
        if(a[0] == b[0]) return a[1]<b[1];
        return a[0]<b[0];
    }
    
    int binarySearch(vector<vector<int>>& chain, int target, int lo, int hi){//0<= lo < hi <= size 
        while(lo < hi){
            int mid = lo + (hi - lo) / 2;
            if (chain[mid][1] >= target)
                hi = mid;
            else   
                lo = mid + 1;
        }
        return lo;
    }
};
~~~

#### [最长摆动子序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

思路：

1. 动态规划：定义一个上升序列和一个下降序列。
2. 贪心：只要当前`nums[i] - nums[i-1]`与`nums[i-1] - nums[i-2]`，则序列长度+1.

~~~c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.empty()) return 0;
        int up = 1, down = 1;
        for(int i = 1; i < nums.size(); i++){
            if(nums[i] > nums[i-1])
                up = down + 1;
            else if(nums[i] < nums[i-1])
                down = up + 1;
        }
        return max(up, down);
    }
};
~~~

~~~c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();
        int prediff = 0;
        int curdiff = 0;
        int res = 1;
        for(int i=1; i < nums.size(); i++){
            curdiff = nums[i] - nums[i-1];
            if((curdiff > 0 && prediff <= 0) || (curdiff < 0 && prediff >= 0)){
                res++;
                prediff = curdiff;
            }
        }
        return res;
    }
};
~~~

### 最长公共子序列

对于两个子序列 S1 和 S2，找出它们最长的公共子序列。

定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 `dp[i][j] `表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1<sub>i</sub> 与 S2<sub>j</sub> 值是否相等，分为两种情况：

- 当 S1<sub>i</sub>==S2<sub>j</sub> 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1<sub>i</sub> 这个值，最长公共子序列长度加 1，即` dp[i][j] = dp[i-1][j-1] + 1`。
- 当 S1<sub>i</sub> != S2<sub>j</sub> 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 `dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }`。

综上，最长公共子序列的状态转移方程为：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecd89a22-c075-4716-8423-e0ba89230e9a.jpg" width="450px"> </div><br>

对于长度为 N 的序列 S<sub>1</sub> 和长度为 M 的序列 S<sub>2</sub>，`dp[N][M] `就是序列 S<sub>1</sub> 和序列 S<sub>2</sub> 的最长公共子序列长度。

与最长递增子序列相比，最长公共子序列有以下不同点：

- 针对的是两个序列，求它们的最长公共子序列。
- **在最长递增子序列中，dp[i] 表示以 S<sub>i</sub> 为结尾的最长递增子序列长度，子序列必须包含 S<sub>i</sub> ；在最长公共子序列中，`dp[i][j] `表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1<sub>i</sub> 和 S2<sub>j</sub>。**
- 在求最终解时，最长公共子序列中 `dp[N][M] `就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 S<sub>N</sub> 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。

#### [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

<img src="https://gitee.com/Raymond-Z/typora/raw/master/image/20201225164613.png" alt="img" style="zoom:50%;" />

比如上图的例子，`d[2][4] `的含义就是：对于 `"ac"` 和 `"babc"`，它们的 LCS 长度是 2。我们最终想得到的答案应该是 `dp[3][6]`。

让索引为 0 的行和列表示空串，`dp[0][..]` 和 `dp[..][0]` 都应该初始化为 0.按照刚才 dp 数组的定义，`dp[0][3]=0` 的含义是：对于字符串 `""` 和 `"bab"`

~~~c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size(), n2 = text2.size();
        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));
        for(int i=1; i<=n1; i++){
            for(int j=1; j<=n2; j++){
                if(text1[i-1] == text2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[n1][n2];
    }
};
~~~

优化思路：dp数组只与相邻的两个有关，能不能优化空间呢？->滚动数组

1. dp方程：


```c++
if(text1[i-1]==text2[j-1]){
	dp[i][j]=dp[i-1][j-1]+1;
}else{
	dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
}
```
2. 在利用二维dp数组记录`dp[i][j]`时，需要用到`dp[i-1][j-1] (左上方),dp[i-1][j] (上边),dp[i][j-1] (左边)`。
3. 优化为滚动数组后，记录`dp[j] (dp[i][j]) `时，`dp[j-1](i-1) `已被更新为`dp[j-1](i)`，所以需定义变量last去记录未被更新前的`dp[j-1][i-1]`;
4. 所以计算dp[j]的当前值时，会用到`last（dp[i-1][j-1]）`、`dp[j] (dp[i-1][j])`和`dp[j-1] (dp[i][j-1])`;
   注意：计算每一行的第一个元素时候，last需要初始化为0。	

~~~c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size(), n2 = text2.size();
        vector<int> dp(n2+1,0);
        int last = 0, temp = 0;
        for(int i=1; i<=n1; i++){
            for(int j=1; j<=n2; j++){
                temp = dp[j];//保存dp[i-1][j],到下一轮即为dp[i-1][j-1]
                if(text1[i-1] == text2[j-1]){
                    dp[j] = last + 1;
                }
                else{
                    dp[j] = max(dp[j], dp[j-1]);
                }
                last = temp;
            }
            last = 0;
        }
        return dp[n2];
    }
};
~~~

### 0-1 背包

有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。

定义一个二维数组 dp 存储最大价值，其中 `dp[i][j] `表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：

- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，`dp[i][j] = dp[i-1][j]`。
- 第 i 件物品添加到背包中，`dp[i][j] = dp[i-1][j-w] + v`。

第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8cb2be66-3d47-41ba-b55b-319fc68940d4.png" width="400px"> </div><br>

在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 `dp[i-1][j] `也可以表示` dp[i][j]`。此时，

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ae89f16-7905-4a6f-88a2-874b4cac91f4.jpg" width="300px"> </div><br>

因为 dp[j-w] 表示` dp[i-1][j-w]`，因此不能先求` dp[i][j-w]`，防止将` dp[i-1][j-w] `覆盖。也就是说要先计算 `dp[i][j] `再计算` dp[i][j-w]`，在程序实现时需要按倒序来循环求解。

[【动态规划】一次搞定三种背包问题 - 弗兰克的猫 - 博客园 (cnblogs.com)](https://www.cnblogs.com/mfrank/p/10849505.html)

#### [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

题目描述：给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

思路：可以看成一个背包大小为 sum/2 的 0-1 背包问题。

~~~c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if(sum % 2 != 0) return false;
        int w = sum/2;
        int n = nums.size();
        vector<vector<bool>> dp(n + 1, vector<bool>(w + 1, false));
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;//背包没有空间的时候，就相当于装满了
        
        for(int i=1; i<=n; i++){
            for(int j=1; j<=w; j++){
                if(j - nums[i-1] < 0){//背包容量不足
                    dp[i][j] = dp[i-1][j];
                }
                else{//不装或者装
                    dp[i][j] = dp[i-1][j] || dp[i-1][j - nums[i-1]];
                }
            }
        }
        return dp[n][w];
    }
};
~~~

优化空间：

~~~c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if(sum % 2 != 0) return false;
        int w = sum/2;
        int n = nums.size();
        vector<bool> dp(w + 1);
        dp[0] = true;//背包没有空间的时候，就相当于装满了
        for(int i=0; i<n; i++){
            for(int j = w; j >= nums[i]; j--){
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[w];
    }
};
~~~

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

未优化空间：

~~~c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        /*
        * sum(P) 前面符号为+的集合；sum(N) 前面符号为减号的集合
        * 所以题目可以转化为
        * sum(P) - sum(N) = target 
        * => sum(nums) + sum(P) - sum(N) = target + sum(nums)
        * => 2 * sum(P) = target + sum(nums) 
        * => sum(P) = (target + sum(nums)) / 2
        * 因此题目转化为01背包，也就是能组合成容量为sum(P)的方式有多少种
        */
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        int sum_p = sum + target;
        if(sum < target || sum_p % 2 != 0 || sum_p < 0) return 0;
        sum_p = sum_p / 2;
        int n = nums.size();
        vector<vector<int>> dp(n+1, vector<int>(sum_p+1));
        // dp[i][j] i为考虑前i个元素，j为容量，dp[i][j]表示目标和为j的方法数
        dp[0][0] = 1;
        for(int i = 1; i <= nums.size(); i++){
            for(int j = 0; j <= sum_p; j++){
                if(j >= nums[i-1]){
                    dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i-1]];
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n][sum_p];
    }
};
~~~

优化空间：

~~~c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        /*
        * sum(P) 前面符号为+的集合；sum(N) 前面符号为减号的集合
        * 所以题目可以转化为
        * sum(P) - sum(N) = target 
        * => sum(nums) + sum(P) - sum(N) = target + sum(nums)
        * => 2 * sum(P) = target + sum(nums) 
        * => sum(P) = (target + sum(nums)) / 2
        * 因此题目转化为01背包，也就是能组合成容量为sum(P)的方式有多少种
        */
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        int sum_p = sum + target;
        if(sum < target || sum_p % 2 != 0 || sum_p < 0) return 0;
        sum_p = sum_p / 2;
        int n = nums.size();
        vector<int> dp(sum_p+1);
        dp[0] = 1;
        // 优化成1维后，需要注意第二次循环是倒序的，且j >= nums[i]。因为j< nums[i]时，这个nums[i]不可能选，也就不需要更新。
        for(int i = 0; i < nums.size(); i++){
            for(int j = sum_p; j >= nums[i]; j--){
                dp[j] += dp[j-nums[i]];
            }
        }
        return dp[sum_p];
    }
};
~~~

### 股票交易

~~先看交易k次的版本，其他都是特例。~~

这个系列要重写，没有人会真的用三维数组去做的傻逼。关键概念是，枚举所有状态，只要能完整的表示出所有状态并合理地转移，就完成了。



~~~c++
dp定义为利润：
dp[i][k][0 or 1]
0 <= i <= n-1, 1 <= k <= K
n 为天数，⼤ K 为最多交易数, 0不持有，1持有股票
    
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity
    
状态转移⽅程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
~~~



#### [买卖股票的最佳时机（买卖一次）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

k=1的情况

~~~c++
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
            = max(dp[i-1][1][1], -prices[i])
解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。
现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进⾏进⼀步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
dp[i]只与dp[i-1]有关，继续优化空间：
~~~

最后简化为只有hold和not_hold两种状态：

~~~c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int not_hold = 0;
        int hold = INT_MIN;
        for (int i = 0; i < n; i++){
            not_hold = max(not_hold, hold + prices[i]);
            hold = max(hold, -prices[i]);//只买卖一次，前面买了一次的利润是0，所以直接-prices[i]
        }
        return not_hold;
    }
};
~~~



#### [买卖股票的最佳时机 II（交易不限次数）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

k=k-1的情况

~~~c++
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
dp[i]只与dp[i-1]有关，继续优化空间：

~~~

最后简化为只有hold和not_hold两种状态，用temp记录上一轮的not_hold：

~~~c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int n = prices.size();
        int hold = INT_MIN;
        int not_hold = 0;
        for(int i = 0; i < n; i++){
            int temp = not_hold;
            not_hold = max(not_hold, hold + prices[i]);
            hold = max(hold, temp - prices[i]);
        }
        return not_hold;
    }
};
~~~

#### [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

题目描述：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ffd96b99-8009-487c-8e98-11c9d44ef14f.png" width="300px"> </div><br>

k=k-1，但有冷冻期，买了能立即卖，但卖了不能立即买。

~~~
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，⽽不是 i-1 。
~~~

最后简化为只有hold和not_hold两种状态，用temp记录上一轮的not_hold，然后在这一天里把temp再传给not_hold_pre，那么到下一轮not_hold_pre就是`dp[i-2][0]`：

~~~c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int n = prices.size();
        int hold = INT_MIN;
        int not_hold = 0;
        int not_hold_pre = 0;//dp[i-2][0]
        for(int i = 0; i < n; i++){
            int temp = not_hold;
            not_hold = max(not_hold, hold + prices[i]);
            hold = max(hold, not_hold_pre - prices[i]);
            not_hold_pre = temp;
        }
        return not_hold;
    }
};
~~~

#### [买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

k=k-1，但（卖出或买入）有手续费

~~~
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
解释：相当于买⼊股票的价格升⾼了。
在第⼀个式⼦⾥减也是⼀样的，相当于卖出股票的价格减⼩了。
~~~

最后简化为只有hold和not_hold两种状态，用temp记录上一轮的not_hold，然后买入收取手续费。但是在卖出时收取则不能初始化hold为INT_MIN，因为一旦prices[i]小于fee，则会造成溢出。

~~~c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        if(prices.empty()) return 0;
        int n = prices.size();
        int hold = INT_MIN;
        int not_hold = 0;
        for(int i = 0; i < n; i++){
            int temp = not_hold;
            not_hold = max(not_hold, hold + prices[i]);
            hold = max(hold, temp - prices[i] - fee);
        }
        return not_hold;
    }
};
~~~



#### [买卖股票的最佳时机 III（交易2次）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

k=2

~~~
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
~~~

但是，k=2的情况下可以枚举出5种状态：

* 未进行过任何操作；
* 只进行过一次买操作；buy1
* 进行了一次买操作和一次卖操作，即完成了一笔交易；sell1
* 在完成了一笔交易的前提下，进行了第二次买操作；buy2
* 完成了全部两笔交易。sell2

进行转移时，不需要保存前一天的临时变量，无论题目中是否允许「在同一天买入并且卖出」这一操作，最终的答案都不会受到影响，这是因为这一操作带来的收益为零。

~~~c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        for (int i = 1; i < n; ++i) {
            buy1 = max(buy1, -prices[i]);
            sell1 = max(sell1, buy1 + prices[i]);
            buy2 = max(buy2, sell1 - prices[i]);
            sell2 = max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
};

~~~



#### [买卖股票的最佳时机 IV（交易k次）](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)



~~~c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }
        int n = prices.size();
        k = min(k, n / 2);//股票交易日子有限
        vector<vector<int>> buy(n, vector<int>(k + 1));
        vector<vector<int>> sell(n, vector<int>(k + 1));
        buy[0][0] = -prices[0];
        sell[0][0] = 0;
        for (int i = 1; i <= k; ++i) {
            buy[0][i] = sell[0][i] = INT_MIN / 2;//不除2就会溢出
        }
        for (int i = 1; i < n; ++i) {
            buy[i][0] = max(buy[i - 1][0], sell[i - 1][0] - prices[i]);//0笔交易
            for (int j = 1; j <= k; ++j) {
                buy[i][j] = max(buy[i - 1][j], sell[i - 1][j] - prices[i]);
                sell[i][j] = max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);   
            }
        }
        return *max_element(sell[n - 1].begin(), sell[n - 1].end());
    }
};
~~~

### 字符串编辑

#### [两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

题目描述：给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

```
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

可以转换为求两个字符串的[最长公共子序列](#最长公共子序列)问题。

~~~c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size(), n2 = text2.size();
        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));
        for(int i=1; i<=n1; i++){
            for(int j=1; j<=n2; j++){
                if(text1[i-1] == text2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return n1 + n2 - 2 * dp[n1][n2];
    }
};
~~~

#### [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

题目描述：修改一个字符串成为另一个字符串，使得修改次数最少。一次修改操作包括：插入一个字符、删除一个字符、替换一个字符。

dp数组的含义

初始化边界值

状态转移方程：从上面下来是在word1[i-1]后面加word2[j]，从左边下来是word2[j-1]后面加word1[i]，从左上角来是替换掉一个。

~~~c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size(), n2 = word2.size();
        if(n1 == 0) return n2;
        if(n2 == 0) return n1;
        vector<vector<int>> dp(n1+1, vector<int>(n2+1));
        
        for(int i=1; i <= n1; i++){
            dp[i][0] = i;
        }
        for(int i=1; i <= n2; i++){
            dp[0][i] = i;
        }
        for(int i=1; i <= n1; i++){
            for(int j=1; j <= n2; j++){
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;
                }
            }
        }
        return dp[n1][n2];

    }
};
~~~

#### [复制粘贴字符](https://leetcode-cn.com/problems/2-keys-keyboard/)

题目描述：最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。

思路：没太想明白

~~~c++
class Solution {
public:
    int minSteps(int n) {
        vector<int> dp(n+1);
        int k = sqrt(n);
        for(int i = 2; i <= n; i++){
            dp[i] = i;
            for(int j = 2; j <= k; j++){
                if(i % j == 0){
                    dp[i] = dp[j] + dp[i/j];
                    break;
                }
            }
        }
        return dp[n];
    }
};
~~~

## 排序

### 快速选择&堆

快速选择：

用于求解   **Kth Element**   问题，也就是第 K 个元素的问题。

可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N<sup>2</sup>)。

堆：

用于求解   **TopK Elements**   问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log<sub>2</sub>N。

堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。

快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。

可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。

#### [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

**排序**：时间复杂度 O(NlogN)，空间复杂度 O(1)

~~~c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() - k];
    }
};
~~~

**堆**  ：时间复杂度 O(NlogK)，空间复杂度 O(K)。

C++中关于优先队列的用法`priority_queue<Type, Container, Functional>`。Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。

当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，**默认是大顶堆**。

~~~c++
priority_queue<Type, Container, Functional>
//升序队列，小顶堆
priority_queue <int,vector<int>,greater<int> > q;
//降序队列，大顶堆
priority_queue <int,vector<int>,less<int> >q;
~~~

代码：

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq;
        for (auto n : nums) {
            if (pq.size() == k && pq.top() >= n) continue;
            if (pq.size() == k) {
                pq.pop();
            }
            pq.push(n);
        }
        return pq.top();
    }
};
```

**快速选择**  ：时间复杂度 O(N)，空间复杂度 O(1)

~~~c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
         return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);

    }
    int quickSelect(vector<int>&a, int l, int r, int index){
        int q = randomPartition(a, l, r);
        if(q == index){
            return a[q];
        }
        else{
            return q < index ? quickSelect(a, q+1, r, index) : quickSelect(a, l, q-1, index);
        }
    }
    int randomPartition(vector<int>&a, int l, int r){
        int i = rand() % (r - l + 1) + l;// [l, r+1)
        swap(a[i], a[r]);
        return partition(a, l, r);
    }
    
    int partition(vector<int>&a, int l, int r){
        int x = a[r], i = l-1;
        for(int j = l; j < r; j++){//j从左往右找小于x的数，i保证[l,i]中的数都小于x
            if(a[j] <= x){
                swap(a[++i], a[j]);
            }
        }//j==r，[l,i]中的数都小于x
        swap(a[i+1], a[r]);
        return i+1;
    }

};
~~~

#### [最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

堆

~~~c++
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        //经典题目了，大顶堆，快排
        if(k == 0) return {};
        priority_queue <int,vector<int>,less<int> >pq;
        //几种情况：堆大小小于k；大小为k但需要入堆；无需入堆
        for(int i : input){
            //入堆
            if(pq.size() < k){
                pq.push(i);
            }
            else{
                if(i < pq.top()){
                    pq.pop();
                    pq.push(i);
                }
            }
        }
        vector<int> res(k);
        for(int i = 0; i < k; i++){
            res[i] = pq.top();
            pq.pop();
        }
        return res;
    }
};
~~~



### 桶排序

#### [前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

题目描述：给定一个非空的整数数组，返回其中出现频率前 k高的元素。

思路：设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。

把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。

这个题的官方题解是用堆来做的。

~~~c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> num_freq;//以每个数字为key，存该数字出现的次数
        int max_freq = 0;
        for(int num : nums){
            num_freq[num] ++;
            if(num_freq[num] > max_freq)
                max_freq = num_freq[num];
        }
        vector<stack<int>> bucket(max_freq+1, stack<int>());//桶的下标是频次，内容是同频次的数字。下标为0的桶为空。
        for(auto& it : num_freq){
            bucket[it.second].push(it.first);
        }
        vector<int> topK;//存答案
        int freq = max_freq;
        while(freq > 0 && topK.size() < k){//控制topK中只存k个
            while(!bucket[freq].empty() && topK.size() < k){//控制topK中只存k个
                topK.push_back(bucket[freq].top());
                bucket[freq].pop();
            }
            freq--;
        }
        return topK;
    }
};
~~~

#### [根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

题目描述：给定一个字符串，请将字符串里的字符按照出现的频率降序排列

思路：和上一题的思路一样，但是结果开销巨大。

~~~c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> char_freq;//
        int max_freq = 0;
        for(char c : s){
            char_freq[c]++;
            max_freq = max(max_freq, char_freq[c]);
        }
        vector<stack<char>> bucket(max_freq+1, stack<char>());
        for(auto& it : char_freq){
            bucket[it.second].push(it.first);
        }
        string res;
        int freq = max_freq;
        while(freq > 0){
            while(!bucket[freq].empty()){
                res.append(freq, bucket[freq].top());
                bucket[freq].pop();
            }
            freq--;
        }
        return res;
    }
};
~~~

改进：直接用`vector<string>`来存同频次的字符，而且直接存为字符串形式。时间提升了，但是内存占用还是很大。

~~~c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> char_freq;//
        int max_freq = 0;
        for(auto& c : s){
            char_freq[c]++;
        }
        vector<string> bucket(s.size()+1);
        for(auto& it : char_freq){
            bucket[it.second].append(it.second, it.first);
        }
        string res;
        for(int i = s.size(); i > 0; i--){
            res += bucket[i];
        }
        return res;
    }
};
~~~

#### 荷兰国旗问题[（颜色分类）](https://leetcode-cn.com/problems/sort-colors/)

荷兰国旗包含三种颜色：红、白、蓝。

有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。

```html
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

题目描述：只有 0/1/2 三种颜色。

思路：0就放在左边，2就放在右边。

~~~c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int left = 0, curr = 0, right = nums.size()-1;//left和right指向未处理的数
        while(curr <= right){
            if(nums[curr] == 0){
                swap(nums[left++], nums[curr++]);
            }
            else if(nums[curr] == 2){
                swap(nums[right--], nums[curr]);//这里cur不能++，因为后面换过来的也是没处理过的。
            }
            else{
                curr++;
            }
        }

    }
};
~~~

## 二分查找

**正常实现**  

```text
Input : [1,2,3,4,5]
key : 3
return the index : 2
```

```java
public int binarySearch(vector<int>& nums, int key) {
    int l = 0, h = nums.length - 1;//l,h都可取到
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] > key) {
            h = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```

**时间复杂度**  

二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。

**m 计算**  

有两种计算中值 m 的方式：

- m = (l + h) / 2
- m = l + (h - l) / 2

l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。

**未成功查找的返回值**  

循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：

- -1：以一个错误码表示没有查找到 key
- l：将 key 插入到 nums 中的正确位置

**变种**  

二分查找可以有很多变种，实现变种要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：

```java
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length;//这里的h又不能取得了，所以下面的while没有用等号，且h=m，而不是h=m-1
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= key) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```

该实现和正常实现有以下不同：

- h 的赋值表达式为 h = m
- 循环条件为 l \< h
- 最后返回 l 而不是 -1

在 nums[m] \>= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。

在 h 的赋值表达式为 h = m 的情况下，如果循环条件为 l \<= h，那么会出现循环无法退出的情况，因此循环条件只能是 l \< h。以下演示了循环条件为 l \<= h 时循环无法退出的情况：

```text
nums = {0, 1, 2}, key = 1
l   m   h
0   1   2  nums[m] >= key
0   0   1  nums[m] < key
1   1   1  nums[m] >= key
1   1   1  nums[m] >= key
...
```

当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。

还有一种数据结构网课讲的：

**找最右位置，要注意判断`lo-1`是否越界**

```c++
int binSearch(vector<int> & nums, int target, int lo, int hi){//0 <= lo < hi <= size
    while(lo < hi){
        int mi = lo + (hi-lo)/2;
        target <  nums[mi] ? hi = mi : lo = mi + 1;//[lo,mi)or(mi,hi)
    }//出口时 lo == hi
    return lo - 1
}
```
**找最左位置呢？**区别就在于，`target =  nums[mi]`时往左还是往右。

~~~c++
int binSearch(vector<int> & nums, int target, int lo, int hi){//0 <= lo < hi <= size
    while(lo < hi){
        int mi = lo + (hi-lo)/2;
        target <=  nums[mi] ? hi = mi : lo = mi + 1;//[lo,mi)or(mi,hi)
    }//出口时 lo == hi
    return lo - 1
}
~~~



#### [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

题目描述：实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

思路：一个数 x 的开方 sqrt 一定在 0 \~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 \~ x 之间查找 sqrt。

对于 x = 8，它的开方是 2.82842...，最后应该返回 2 而不是 3。在循环条件为 l \<= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。

~~~c++
class Solution {
public:
    int mySqrt(int x) {
        if(x <= 1) return x;
        int l = 1, h = x;//h可取得
        while(l <= h){//退出时，h=l-1
            int mid = l+(h-l)/2;
            int sqrt = x / mid;
            if(mid == sqrt){
                return mid;
            }
            else if(sqrt < mid){
                h = mid - 1;
            }
            else{
                l = mid + 1;
            }
        }
        return h;
    }
};
~~~

#### [寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

题目描述：给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。

在比较时，字母是依序循环出现的。举个例子：

如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'

思路：因为字符列表是有重复的，所以不能用第一种写法。而且变种是找重复元素的最左位置，这题中要找到最右位置。

**要特别注意边界问题，因为返回的是下一个元素。**

~~~c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int lo = 0, hi = letters.size();
        while(lo < hi){//结束时hi=lo
            int mid = lo + (hi - lo)/2;
            target < letters[mid]? hi = mid : lo = mid + 1;
        }
        return (0 <= lo-1 && lo-1 < letters.size()-1) ? letters[lo] : letters[0];
    }
};
~~~

#### [有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

题目描述：给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

```
输入: [1,1,2,3,3,4,4,8,8]
输出: 2
```

思路：以前做过类似的，可以用异或来做。

~~~c++
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int res = 0;
        for(int num : nums){
            res ^= num;
        }
        return res;
    }
};
~~~

但是题目要求O(log n)时间复杂度和 O(1)空间复杂度中运行。而异或的方法时间复杂度是O(n)。

二分法思路：令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 \< index，那么 nums[m] == nums[m + 1]；m + 1 \>= index，那么 nums[m] != nums[m + 1]。

从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。

因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l \< h 这种形式。

~~~c++
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;//这里要保持hi为偶数，而nums.size()一定为奇数
        while(lo < hi){//结束时lo = hi
            int mi = lo + (hi - lo)/2;
            if(mi % 2 == 1){
                mi--;// 保证 lo/hi/mi 都在偶数位，使得查找区间大小一直都是奇数
            }
            if(nums[mi] == nums[mi+1]){
                lo = mi + 2;
            }
            else{
                hi = mi;
            }
        }
        return nums[lo];
    }
};
~~~

#### [第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

题目描述：给定一个元素 n 代表有 [1, 2, ..., n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。

思路：如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。

因为 h 的赋值表达式为 h = m，因此循环条件为 l \< h。

~~~c++
class Solution {
public:
    int firstBadVersion(int n) {
        int lo = 1, hi = n;
        while(lo < hi){
            int mi = lo + (hi-lo)/2;
            isBadVersion(mi) ? hi = mi : lo = mi+1;
        }
        return lo;
    }
};
~~~

#### [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。

请找出其中最小的元素。

思路：边界情况很难搞清楚。判断条件是跟谁比，怎么比？**`nums[mi]`和`nums[lo]`比是不行的，因为两边子序列都是递增的。当nums[mi]和nums[lo]都处于同一段子序列时，无法判断最小值在[mid，hi]**

~~~c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        while(lo < hi){
            int mi = lo + (hi - lo)/2;
            nums[mi] < nums[hi]? hi = mi : lo = mi+1;//[lo,mi)or(mi,hi)
        }
        return nums[lo];
    }
};
~~~

#### [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

题目描述：有重复值。

思路：注意`[1,3,3]`和`[3,3,1,3]`两个例子，当`nums[mi] == nums[hi]`时，最小值可能在左边也可能在右边，但唯一确定的是一定在hi的左边。所以让hi向左靠近。

~~~c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        while(lo < hi){
            int mi = lo + (hi - lo)/2;
            if(nums[mi] < nums[hi]){
                hi = mi;
            }
            else if(nums[mi] > nums[hi]){
                lo = mi + 1;
            }
            else{
                hi--;
            }
        }
        return nums[lo];
    }
};
~~~

#### [在排序数组中查找元素的第一个和最后一个位置（与剑指53相同）](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

思路：分别用二分法找不大于target的最后一个元素和不小于target的第一个元素。或者希望代码重用的话，用二分法找不大于target的最后一个元素，和找不大于target+1的最后一个元素。

~~~c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.empty()){
            return vector<int>{-1, -1};
        }
        int lo = 0, hi = nums.size();
        while(lo < hi){
            int mi = lo + (hi-lo)/2;
            target < nums[mi] ? hi = mi : lo = mi+1;
        }
        int end = 0;
        if(lo-1 >= 0 && nums[lo-1] == target){
            end = lo-1;
            lo = 0;
            hi = nums.size();
        }
        else{
            return vector<int>{-1, -1};
        }
        while(lo < hi){
            int mi = lo + (hi-lo)/2;
            target > nums[mi] ? lo = mi+1 : hi = mi;
        }
        return vector<int>{lo, end};
    }
};
~~~

## 贪心思想

**核心思想：保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。**

#### [分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```html
Input: grid[1,3], size[1,2,4]
Output: 2
```

题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。

1. 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。
2. 因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。

~~~c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        if(s.empty()) return 0;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int gi = 0, si = 0;
        while(si < s.size() && gi < g.size()){
            if(s[j] >= g[i]){
                gi++;
            }
            si++;
        }
        return gi;
    }
};
~~~

#### [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

题目描述：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠
```

先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。

在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。

按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。

~~~c++
class Solution {
public:
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.empty()) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 1;
        int end = intervals[0][1];
        for(int i = 1; i < intervals.size(); i++){
            if(intervals[i][0] >= end){
                end = intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
~~~

#### [用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。

思路：也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。

比之前的版本快了很多，

~~~c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b){
        return a[1] < b[1];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        if (points.empty()) return 0;
        sort(points.begin(), points.end(), cmp);
        int count = 1, end = points[0][1];
        for(int i = 1; i < points.size(); i++){
            if(points[i][0] > end){
                count++;
                end = points[i][1];
            }
        }
        return count;
    }
};
~~~

#### [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。

~~~
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
~~~

思路：**为了使插入操作不影响后续的操作**，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。

个子高的先站进队列，个子矮的随便站哪都个高的都没影响；但是个矮的先站了，个高的就不能站个矮的前面了。

身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。

知识点：vector的insert方法第一个参数是迭代器，不是下标：`iterator insert (iterator position, const value_type& val);`

~~~c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b){
        if(a[0] == b[0]){
            return a[1] < b[1];//k升序
        }
        return a[0] > b[0];//身高降序
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> queue;
        for(auto & person : people){
            queue.insert(queue.begin() + person[1], person);
        }
        return queue;
    }   
};
~~~

#### [种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

题目描述：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。

思路：核心都是连续三个0就可以种下一朵花，但是在边界情况可以有两种处理：

1. 前后都补上一个0，这样就可以判断前中后三位都是0时种花
2. 判断前和后时判断是不是首尾。

~~~c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int len = flowerbed.size();
        for(int i = 0; i < len && n > 0; i++){
            if(flowerbed[i] == 1){
                continue;
            }
            int pre = i == 0 ? 0 : flowerbed[i-1];
            int next = i == len-1 ? 0 : flowerbed[i+1];
            if(pre == 0 && next == 0){
                flowerbed[i] = 1;
                n--;
            }
        }
        return n <= 0;
    }
};
~~~

#### [判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

题目描述：字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。进阶：s较短但t很长。

思路：第一想法是双指针，但是双指针的时间复杂度：O(n+m)，其中 n为 s 的长度，m 为 t的长度。题解的思路是直接调用find在t中找s中的每个字母，一旦没找到就返回false。

官方题解是双指针和动态规划。

~~~c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int index = -1;
        for(char c : s){
            index = t.find(c, index+1);
            if(index == -1){
                return false;
            }
        }
        return true;
    }
};
~~~

#### [非递减数列](https://leetcode-cn.com/problems/non-decreasing-array/)

题目描述：判断一个数组是否能只修改一个数就成为非递减数组。

~~~
Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
~~~

思路：尽量让数组更小，也就是修改`nums[i-1] = nums[i];`。但是也有特殊情况

	4，2，3
	-1，4，2，3
	2，3，3，2，4
首先如果再前面的数不存在，比如例子1，4前面没有数字了，我们直接修改前面的数字为当前的数字2即可。
而当再前面的数字存在，并且小于当前数时，比如例子2，-1小于2，我们还是需要修改前面的数字4为当前数字2；
如果再前面的数大于当前数，比如例子3，3大于2，我们需要修改当前数2为前面的数3。

~~~c++
class Solution {
public:
    bool checkPossibility(vector<int>& nums) {
        int cnt = 0;
        for(int i = 1; i < nums.size() && cnt < 2; i++){
            if(nums[i] >= nums[i-1]){
                continue;
            }
            cnt++;
            if(i >=2 && nums[i-2] > nums[i]){
                nums[i] = nums[i-1];
            }
            else{
                nums[i-1] = nums[i];
            }
        }
        return cnt <= 1;
    }
};
~~~

#### [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

题目描述：给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

思路：只要之前的和小于0，那就不要之前的，从当前元素开始重新计算和。

~~~c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int preSum = nums[0];
        int maxSum = nums[0];
        for(int i = 1; i < nums.size(); i++){
            preSum = preSum > 0 ? preSum + nums[i] : nums[i];
            maxSum = max(preSum, maxSum);
        }
        return maxSum;
    }
};
~~~

#### [划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

题目描述：字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

~~~
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
~~~

思路：感觉像个回溯问题。怎么用贪心做呢？

~~~c++
class Solution {
public:
    vector<int> partitionLabels(string S) {
        int last[26];
        int length = S.size();
        for (int i = 0; i < length; i++) {
            last[S[i] - 'a'] = i;
        }
        vector<int> partition;
        int start = 0, end = 0;
        for (int i = 0; i < length; i++) {
            end = max(end, last[S[i] - 'a']);
            if (i == end) {
                partition.push_back(end - start + 1);
                start = end + 1;
            }
        }
        return partition;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~

## 搜索

### BFS

在程序实现 BFS 时需要考虑以下问题：

- 队列：用来存储每一轮遍历得到的节点；
- 标记：对于遍历过的节点，应该将它标记，防止重复遍历。

#### [二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

题目描述：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。

思路：每次循环先处理上一层入队的坐标，访问到右下角就输出

~~~c++
class Solution {
public:
    vector<vector<int>> direction={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        if(grid[0][0] == 1) return -1;
        int n = grid.size();
        queue<pair<int, int>> q;//记录坐标
        q.push(make_pair(0, 0));
        int length = 1;
        grid[0][0] = 2;
        while(!q.empty()){
            int l = q.size();
            for(int i = 0; i < l; i++){
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if(x == n-1 && y == n-1){//访问到了右下角
                    return length;
                }
                for(int j = 0; j < 8; j++){
                    int x1 = x + direction[j][0];
                    int y1 = y + direction[j][1];
                    if(x1 < 0 || y1 < 0 || x1 >=n || y1 >= n || grid[x1][y1]){//坐标越界或者该点不通(1或2)
                        continue;
                    }
                    grid[x1][y1] = 2;
                    q.push(make_pair(x1, y1));
                }
            }
            length++;
        }
        return -1;
    }
};
~~~

#### [单词接龙（困难）](https://leetcode-cn.com/problems/word-ladder/)

题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

### DFS

在程序实现 DFS 时需要考虑以下问题：

- 栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
- 标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。

#### [岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

题目描述：给定一个包含了一些 `0` 和 `1` 的非空二维数组 `grid` 。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

思路：这种网格题都会用到上下左右作为索引、是否越界和是否符合条件。

疑问：为什么递归调用的dfs会特别快？

法一：递归调用（dfs）

~~~c++
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        for(int x = 0; x < n; x++){
            for(int y = 0; y < m; y++){
                ans = max(ans, dfs(grid, x ,y));
            }
        }
        return ans;
    }

    int dfs(vector<vector<int>>& grid, int cur_x, int cur_y){
        int n = grid.size(), m = grid[0].size();
        if(cur_x < 0 || cur_y < 0 || cur_x >= n || cur_y >= m || grid[cur_x][cur_y] != 1){//坐标越界或当前坐标为海水
            return 0;
        }
        grid[cur_x][cur_y] = 0;//访问过设为0
        int d_x[4] = {0, 0, 1, -1};
        int d_y[4] = {1, -1, 0, 0};
        int ans = 1;
        for(int i = 0; i < 4; i++){
            int next_x = cur_x + d_x[i];
            int next_y = cur_y + d_y[i];
            ans += dfs(grid, next_x, next_y);
            }
        return ans;
        }

};
~~~

法二：栈。但是效率低很多，只击败5%。

~~~c++
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        for (int i = 0; i != n; ++i) {
            for (int j = 0; j != m; ++j) {
                int cur = 0;
                stack<pair<int, int>> st;
                st.push(make_pair(i, j));
                while (!st.empty()) {
                    int cur_i = st.top().first, cur_j = st.top().second;
                    st.pop();
                    if (cur_i < 0 || cur_j < 0 || cur_i >= n || cur_j >= m || grid[cur_i][cur_j] != 1) {
                        continue;
                    }
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        st.push(make_pair(next_i, next_j));
                    }
                }
                ans = max(ans, cur);
            }
        }
        return ans;
    }
};
~~~



法三：bfs（队列）。同样也很慢。

~~~c++
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i) {
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                queue<int> queuei;
                queue<int> queuej;
                queuei.push(i);
                queuej.push(j);
                while (!queuei.empty()) {
                    int cur_i = queuei.front(), cur_j = queuej.front();
                    queuei.pop();
                    queuej.pop();
                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {
                        continue;
                    }
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        queuei.push(next_i);
                        queuej.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        }
        return ans;
    }
};
~~~

#### [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

题目描述：给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

dfs思路：同样的dir方向和隐式递归调用和访问标记。但是很慢？

~~~c++
class Solution {
private:
    int m, n;
    vector<vector<int>> direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public:
    int numIslands(vector<vector<char>>& grid) {
        m = grid.size();
        n = grid[0].size();
        int res = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == '1'){
                    dfs(grid, i, j);
                    res++;
                }
            }
        }
        return res;
    }
    void dfs(vector<vector<char>>& grid, int i, int j){
        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0'){
            return;//要找的是岛屿的数量，只要完全找出就退出dfs
        }
        grid[i][j] = '0';//访问标记
        for(auto d : direction){
            dfs(grid, i + d[0], j + d[1]);
        }
    }
};
~~~

题解的写法，搞不清楚是哪里导致的时间开销。

~~~c++
class Solution {
private:
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int nr = grid.size();
        int nc = grid[0].size();

        grid[r][c] = '0';
        if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);
        if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);
        if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);
        if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
};
~~~

#### [被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

题目描述：使被 'X' 包围的 'O' 转换为 'X'。

思路：对于每一个边界上的 `O`，我们以它为起点，标记所有与它直接或间接相连的字母 `O`为T；

最后我们遍历这个矩阵，对于每一个字母：
如果该字母为T，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；
如果该字母为O，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。

~~~c++
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        for(int i = 0; i < n; i++){
            dfs(board, i, 0);
            dfs(board, i, m-1);
        }
        for(int i = 0; i < m; i++){
            dfs(board, 0, i);
            dfs(board, n-1, i);
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(board[i][j] == 'T') board[i][j] = 'O';
                else if(board[i][j] == 'O') board[i][j] = 'X';
            }
        }
    }
    void dfs(vector<vector<char>>& board, int x, int y){
        if(x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != 'O'){
            return;
        }
        board[x][y] = 'T';
        dfs(board, x-1, y);
        dfs(board, x+1, y);
        dfs(board, x, y-1);
        dfs(board, x, y+1);
    }
};
~~~

#### [太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

题目描述：左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。

思路：从四面开始向中间走高处，分别标记是否能流到太平洋或大西洋。

~~~
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
~~~

~~~c++
class Solution {
private:
    int direction[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {
        if(matrix.size() == 0) return {};
        int n = matrix.size();
        int m = matrix[0].size();
        vector<vector<bool>> canReachP(n, vector<bool>(m, false));
        vector<vector<bool>> canReachA(n, vector<bool>(m, false));
        for(int i = 0; i < n; i++){
            dfs(matrix, i, 0, canReachA);
            dfs(matrix, i, m-1, canReachP);
        }
        for(int i = 0; i < m; i++){
            dfs(matrix, 0, i, canReachA);
            dfs(matrix, n-1, i, canReachP);
        }
        vector<vector<int>> res;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(canReachA[i][j] && canReachP[i][j]){
                    res.push_back({i, j});
                }
            }
        }
        return res;
    }
    void dfs(vector<vector<int>>& matrix, int i, int j, vector<vector<bool>>& canReach){
        if(canReach[i][j]){//已访问
            return;
        }
        canReach[i][j] = true;
        for (auto d : direction) {
            int next_i = d[0] + i;
            int next_j = d[1] + j;
            if (next_i < 0 || next_i >= matrix.size() || next_j < 0 || next_j >= matrix[0].size() || matrix[i][j] > matrix[next_i][next_j]) {
                continue;
            }
            dfs(matrix, next_i, next_j, canReach);
        }
    }
};
~~~

### Backtracking

Backtracking（回溯）属于 DFS。

- 普通 DFS 主要用在   **可达性问题**  ，这种问题只需要执行到特点的位置然后返回即可。
- 而 Backtracking 主要用于求解   **排列组合**   问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

#### [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

思路：用全局变量记录结果，当前字符串temp，KEYS列表。回溯的套路大概是入栈，dfs，出栈，且dfs入口处判断是都到达末尾，到达则保存。

~~~c++
class Solution {
private:
    string KEYS[10]={"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> res;
    string temp;
public:
    void dfs(int pos, string& digits){//pos是针对digits的
        if(pos == digits.size()){
            res.push_back(temp);
            return;
        }
        int curDigits = digits[pos]-'0';//因为输入的digits是string形式，要转成int
        for(char c : KEYS[curDigits]){
            temp.push_back(c);
            dfs(pos+1, digits);//如果pos+1 == digits.size()，会返回这里继续执行
            temp.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0) return res;
        dfs(0, digits);
        return res;
    }
};
~~~

#### [复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

题目描述:**有效 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是"0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。

思路：无

~~~c++
class Solution {
private:
    vector<string> ans;
    vector<int> segments;
public:
    void dfs(string& s, int segId, int segStart){
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if(segId == 4){
            if(segStart == s.size()){
                string ipAddr;
                for(int i = 0; i < 4; i++){
                    ipAddr += to_string(segments[i]);
                    if(i != 3){
                        ipAddr += ".";
                    }
                }
                ans.push_back(move(ipAddr));
            }
            return;
        }
        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if(segStart == s.size()){
            return;
        }
        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if(s[segStart] == '0'){
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }
        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for(int segEnd = segStart; segEnd < s.size(); segEnd++){
            addr = addr * 10 + (s[segEnd] - '0');
            if(addr > 0 && addr  <= 0xFF){
                segments[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            }
            else{
                break;
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        segments.resize(4);
        dfs(s, 0, 0);
        return ans;

    }
};
~~~

#### [单词搜索](https://leetcode-cn.com/problems/word-search/)

题目描述：给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

思路：从二维表格的每一个格子出发。进入回溯函数时，判断此路到这是否通，是否结束。通且尚未结束则往上下左右走，任意一条通则成功。

~~~c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++){
            for(int j = 0; j < board[0].size(); j++){
                if(backtrack(board, word, 0, i, j)){
                    return true;
                }
            }
        }
        return false;
    }
    bool backtrack(vector<vector<char>>& board, const string& word, int wordIndex, int i, int j){
        if(board[i][j] != word[wordIndex]){//此路不通
            return false;
        }
        //以下均为board[i][j] == word[wordIndex]
        if(word.size() - 1 == wordIndex){
            return true;
        }
        char tmp = board[i][j];//临时保存
        board[i][j] = '0';
        wordIndex++;
        //上下左右只要有一条通就行
        if((i > 0 && backtrack(board, word, wordIndex, i-1, j))
        || (i < board.size()-1 && backtrack(board, word, wordIndex, i+1, j))
        || (j > 0 && backtrack(board, word, wordIndex, i, j-1))
        || (j < board[0].size()-1 && backtrack(board, word, wordIndex, i, j+1))
        ){
            return true;
        }
        //都不通，那么还原并回溯
        board[i][j] = tmp;
        return false;
    }
};
~~~

#### [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

题目描述：给定一个二叉树，返回所有从根节点到叶子节点的路径。

思路：回溯可以用递归实现。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。

递归调用版本：

~~~c++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> paths;
        dfs(root, "", paths);
        return paths;
    }
    void dfs(TreeNode* root,string cur_path, vector<string>& paths){
        if(root){
            cur_path += to_string(root->val);
            if(root->left == nullptr && root->right == nullptr){//当前节点是叶子节点
                paths.push_back(cur_path);
            }
            else{
                cur_path += "->";
                dfs(root->left, cur_path, paths);
                dfs(root->right, cur_path, paths);
            }
        }
    }
};
~~~

非递归调用版本：

~~~c++

~~~

#### [全排列](https://leetcode-cn.com/problems/permutations/)

题目描述：给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

思路：回溯操作包括tmp的删除末尾元素和visited的设false。

~~~c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        vector<bool> visited(nums.size(), false);
        backtracking(nums, res, tmp, visited);
        return res;

    }
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& tmp, vector<bool>& visited){
        if(tmp.size() == nums.size()){
            res.push_back(tmp);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(visited[i]){//访问过
                continue;
            }
            visited[i] = true;
            tmp.push_back(nums[i]);
            backtracking(nums, res, tmp, visited);
            tmp.pop_back();
            visited[i] = false;
        }
    }
};
~~~

#### [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

题目描述：给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

思路：数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。

在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。

~~~c++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        vector<bool> visited(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, res, tmp, visited);
        return res;
    }
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& tmp, vector<bool>& visited){
        if(tmp.size() == nums.size()){
            res.push_back(tmp);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(i != 0 && nums[i] == nums[i-1] && !visited[i-1]){//防止重复
                continue;
            }
            if(visited[i]){//访问过
                continue;
            }
            visited[i] = true;
            tmp.push_back(nums[i]);
            backtracking(nums, res, tmp, visited);
            tmp.pop_back();
            visited[i] = false;
        }
    }
};

~~~

#### [组合](https://leetcode-cn.com/problems/combinations/)

题目描述：给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

直接思路：回溯法解决组合问题和排序问题不同的是，在组合问题中元素的顺序不考虑，只需要从当前位置向后寻找。排序问题每次都需要从头寻找，需要用visited数组记录访问过的元素。注意每次开始的start都是上一层的i。

~~~c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> tmp;
        backtracking(1, n, k, tmp, res);
        return res;
    }
    void backtracking(int start, int n, int k, vector<int>& tmp, vector<vector<int>>& res){
        if(tmp.size() == k){
            res.push_back(tmp);
            return;
        }
        for(int i = start; i <= n; i++){
            tmp.push_back(i);
            backtracking(i+1, n, k, tmp, res);
            tmp.pop_back();
        }
    }
};
~~~

改进思路：剪枝，要取k个数说明当前最多只能取到n-k+1的位置

~~~c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> tmp;
        backtracking(1, n, k, tmp, res);
        return res;
    }
    void backtracking(int start, int n, int k, vector<int>& tmp, vector<vector<int>>& res){
        if(tmp.size() == k){
            res.push_back(tmp);
            return;
        }
        for(int i = start; i <= n-(k-tmp.size())+1; i++){//剪枝，要取k个数说明当前最多只能取到n-k+1的位置
            tmp.push_back(i);
            backtracking(i+1, n, k, tmp, res);
            tmp.pop_back();
        }
    }
};
~~~

#### [组合总和](https://leetcode-cn.com/problems/combination-sum/)

题目描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。`candidates` 中的数字可以无限制重复被选取。

思路：排序双指针是不行的，因为可以重复选取。就套回溯的思路就可以，先把candidates排序，方便剪枝：一旦出现过大的数，后面都不要了。

~~~c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> tmp;
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, res, tmp, 0);
        return res;
    }
    void backtracking(vector<int>& candidates, int target, vector<vector<int>>& res, vector<int>& tmp, int start){
        if(target == 0){
            res.push_back(tmp);
            return;
        }
        for(int i = start; i < candidates.size(); i++){
            if(target < candidates[i]){
                return;
            }
            tmp.push_back(candidates[i]);
            target -= candidates[i];
            backtracking(candidates, target, res, tmp, i);
            target += candidates[i];
            tmp.pop_back();
        }
    }
};
~~~

#### [含有相同元素的组合求和](https://leetcode-cn.com/problems/combination-sum-ii/)

题目描述：给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。

思路：变化是有重复元素和使用一次。只能用一次那么就从下一个位置开始搜索。怎么防止重复呢？防止一种情况发生：用当前代替了上一个。

~~~c++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> tmp;
        vector<bool> visited(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, res, tmp, 0, visited);
        return res;
    }
    void backtracking(vector<int>& candidates, int target, vector<vector<int>>& res, vector<int>& tmp, int start, vector<bool>& visited){
        if(target == 0){
            res.push_back(tmp);
            return;
        }
        for(int i = start; i < candidates.size(); i++){
            if(target < candidates[i]){
                return;
            }
            if(i > 0 && candidates[i] == candidates[i - 1] && !visited[i-1]){//避免重复：这个和上一个一样，上一个还没用上。等价于用这个替代了上一个。
                continue;
            }
            tmp.push_back(candidates[i]);
            target -= candidates[i];
            visited[i] = true;
            backtracking(candidates, target, res, tmp, i+1, visited);
            visited[i] = false;
            target += candidates[i];
            tmp.pop_back();
            
        }
    }
};
~~~

#### [1-9 数字的组合求和](https://leetcode-cn.com/problems/combination-sum-iii/)

题目描述：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

思路：记得k的剪枝。只剩k个数，则`i <= 9 - k + 1`。

~~~c++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> tmp;
        backtracking(k, n, tmp, res, 1);
        return res;
    }
    void backtracking(int k, int n, vector<int>& tmp, vector<vector<int>>& res, int start){
        if(n < 0 || k < 0){
            return;
        }
        if(k == 0 && n == 0){
            res.push_back(tmp);
            return;
        }
        for(int i = start; i <= 9 - k + 1; i++){
            tmp.push_back(i);
            backtracking(k-1, n-i, tmp, res, i+1);
            tmp.pop_back();
        }
    }
};
~~~

#### [子集](https://leetcode-cn.com/problems/subsets/)

题目描述：给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

思路：没有了控制长度的固定的k，k的范围是`0 ~ nums.size()`。

~~~c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        for(int size = 0; size <= nums.size(); size++){
            backtracking(nums, res, tmp, size, 0);
        }
        return res;
    }
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& tmp, int size, int start){
        if(tmp.size() == size){
            res.push_back(tmp);
            return;
        }
        for(int i = start; i < nums.size(); i++){
            tmp.push_back(nums[i]);
            backtracking(nums, res, tmp, size, i+1);
            tmp.pop_back();
        }
    }
};
~~~

#### [含有相同元素求子集](https://leetcode-cn.com/problems/subsets-ii/)

题目描述：给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。**说明：**解集不能包含重复的子集。

思路：防止一种情况发生：用当前代替了上一个相同的元素。

~~~c++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        vector<bool> visited(nums.size(), false);
        sort(nums.begin(), nums.end());
        for(int size = 0; size <= nums.size(); size++){
            backtracking(nums, res, tmp, size, 0, visited);
        }
        return res;
    }
    void backtracking(vector<int>& nums, vector<vector<int>>& res, vector<int>& tmp, int size, int start, vector<bool>& visited){
        if(tmp.size() == size){
            res.push_back(tmp);
            return;
        }
        for(int i = start; i < nums.size(); i++){
            if(i > 0 && nums[i] == nums[i-1] && !visited[i-1]){
                continue;
            }
            tmp.push_back(nums[i]);
            visited[i] = true;
            backtracking(nums, res, tmp, size, i+1, visited);
            visited[i] = false;
            tmp.pop_back();
        }
    }
};
~~~

#### [分割字符串使得每个部分都是回文数](https://leetcode-cn.com/problems/palindrome-partitioning/)

题目描述：给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。返回 *s* 所有可能的分割方案。

思路：分割后判断子串是否是回文？判断回文用头尾双指针。子串一定是连续的，组合可以不连续。

~~~
For example, given s = "aab",
Return

[
  ["aa","b"],
  ["a","a","b"]
]
i=0时， “”和“aab“
i=1时，“a”和“ab”，a入res，ab继续分
i=2，“aa”和“b”
~~~



~~~c++
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        vector<string> tmp;
        dopartition(s, res, tmp);
        return res;
    }
    void dopartition(string s, vector<vector<string>>& res, vector<string>& tmp){//这里不能写string& s
        if(s.size() == 0){
            res.push_back(tmp);
            return;
        }
        for(int i = 0; i < s.size(); i++){
            if(isPalindrome(s, 0, i)){//前半段是回文，后半段继续分
                tmp.push_back(s.substr(0, i+1));
                dopartition(s.substr(i+1), res, tmp);
                tmp.pop_back();
            }
        }
    }
    bool isPalindrome(string& s, int start, int end){
        while(start < end){
            if(s[start++] != s[end--]){
                return false;
            }
        }
        return true;
    }
};
~~~

# 数据结构专题

## 字符串

#### [3. 无重复字符的最长子串 ](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

描述：给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

思路：记录每个字符最后出现的下标，最长长度，当前长度；逐次判断是否出现过、是否在窗口内。

~~~c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        /*
        子串是要连续的。
        记录每个字符最后出现的下标，最长长度，当前长度；
        */
        int max_len = 0, tmp_len = 0;
        unordered_map<char, int> map;//字符-最后一次出现的下标
        for(int i = 0; i < s.size(); i++){
            auto iter = map.find(s[i]);
            if(iter != map.end()){
                //找到了,得判断这个重复的在不在窗口内
                if(iter->second >= i - tmp_len){
                    //在窗口内，那么这段记录结束，从上一个该字符出现的位置的下一个计算
                    tmp_len = i - iter->second -1;
                }
            }
            tmp_len++;
            max_len = max(max_len, tmp_len);
            map[s[i]] = i;
        }
        return max_len;
    }
};
~~~



## 数组

#### [1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)

描述：给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。

如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。

已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti <= x <= endi ，那么我们称整数x 被覆盖了。

思路：暴力法，遍历range，在每个节点起始位置和终点位置之间的flag标记为true，代表该点已经被包含。

差分数组+前缀和法 ：最关键是对差分数组求前缀和。sum，发现在覆盖的地方，都是正数，而没有覆盖的地方为0。所以差分数组前缀和不仅能查询是否被覆盖，还能查询某一区间被覆盖几次。

~~~c++
class Solution {
public:
    bool isCovered(vector<vector<int>>& ranges, int left, int right) {
        //第一次听到差分数组前缀和的思路。
        //用一个数组记录每一段的开始和结束位置，然后计算这个差分数组的前缀和。
        //前缀和记录的是覆盖的次数。
        vector<int> diff(52,0);
        for(auto range : ranges){
            diff[range[0]] += 1;    //头+1
            diff[range[1]+1] -= 1;  //结尾的后一个-1
        }
        vector<int> sum(52,0);
        for(int i = 1; i < diff.size(); i++){
            sum[i] = sum[i-1] + diff[i];
        }
        for(int j = left; j <= right; j++){
            if(sum[j] <= 0) return false;
        }
        return true;
    }
};
~~~

#### [287. 寻找重复数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-the-duplicate-number/submissions/)

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

要求时间复杂度O(N),空间复杂度O(1);

思路：节省空间复杂度的方法，利用保存着1～N-1这个条件。具一个特例，重复的数字出现两次，那么1～N-1都至少出现一次，当这些数字在自己的位置即a[n]=n,此时出现a[0]的数字就是重复的。

<img src="https://gitee.com/Raymond-Z/typora/raw/master/image/20211013220357.png" alt="img" style="zoom:50%;" />

a[0]保存的肯定不是0，
① 假设a[0]= 3, a[3]=5, 将a[0]与a[3]交换， a[3]=3
② 现在a[0]=5,  再将a[0]与a[5]交换， a[5]=5
③ a[0] = x, 再将a[0] 与 a[x]交换    a[x] = x
直到交换到, 该位置中的数与我想换进去的数相等则跳出。

<img src="https://gitee.com/Raymond-Z/typora/raw/master/image/20211013220413.png" alt="img" style="zoom:50%;" />

~~~c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        while(nums[0] != nums[nums[0]]){
            swap(nums[0] ,nums[nums[0]]);
        }
        return nums[0];
    }
};
~~~



## 链表

#### [相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

题目描述：编写一个程序，找到两个单链表相交的起始节点。

思路：设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。

~~~c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* l1 = headA;
        ListNode* l2 = headB;
        while(l1 != l2){
            l1 = (l1 == NULL)? headB : l1->next;
            l2 = (l2 == NULL)? headA : l2->next;
        }
        return l1;
    }
};
~~~

#### [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

~~~
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
~~~

递归：先找到4，然后通过操作4把5指向4。因为找到5之后就找不到4了。

~~~c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next){
            return head;
        }
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;//第一次执行这条语句的是4
        head->next = nullptr;
        return newHead;
    }
};
~~~

迭代：有点像动态规划？把一次翻转过程画清楚就知道了。

~~~c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while(cur){
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
~~~

#### [反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
//以1->2->3->4->5, m = 2, n=4 为例
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* preHead = new ListNode();
        preHead->next = head;
        ListNode* pre = preHead;
        for(int i = 1; i < left; i++){
            pre = pre->next;
        }
        head = pre->next;
        for(int i = left; i < right; i++){
            ListNode* next = head->next;    // 备份3；next = 3
            head->next = next->next;    //断2->3,连2->4
            next->next = pre->next; //断3->4,连3->2
            pre->next = next;   //断1->2,连1->3
        }
        return preHead->next;
    }
};
~~~



#### [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

题目描述：将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

思路：

递归：两个链表头部值较小的一个节点与剩下元素的 `merge` 操作结果合并。

~~~c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1) return l2;
        if(!l2) return l1;
        if(l1->val < l2->val){
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        else{
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
~~~

迭代：当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。

~~~c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(-1);//哨兵节点
        ListNode* pre = head;//重命名，避免哨兵丢失
        while(l1 && l2){
            if(l1->val < l2->val){
                pre->next = l1;
                l1 = l1->next;
            }
            else{
                pre->next = l2;
                l2 = l2->next;
            }
            pre = pre->next;
        }
        pre->next = l1 == nullptr? l2 : l1;
        return head->next;
    }
};
~~~

#### [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

思路：和剑指的[18.2 删除链表中重复的结点](#18.2 删除链表中重复的结点)差不多，只不过这个是保留一个。可以迭代和递归。

迭代：当遇到重复的，删除后面那个，cur不动。当前后不重复才往后走。效率不咋地。

~~~c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* cur = head;
        while(cur && cur->next){
            if(cur->val == cur->next->val){
                cur->next = cur->next->next;
            }
            else{
                cur = cur->next;
            }
        }
        return head;
    }
};
~~~

#### [删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

思路：剑指offe里有，快慢双指针，fast先走n步，slow再出发。fast到终点时slow正好指向倒数第N个。边界情况挺复杂的

~~~
设链表长度为M
M=1,N=1
~~~

~~~C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(n == 0){
            return head;
        }
        ListNode* node = new ListNode(-1);
        node->next = head;
        ListNode* fast = node;
        while(fast && n--){
            fast = fast->next;
        }
        if(!fast && n >0){//n比链表长度还长
            return nullptr;
        }
        ListNode* slow = node;
        while(fast->next){
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return node->next;
    }
};
~~~

递归：每拿到一个节点，若空则返回，否则往后走；走到最后一个为空，返回空本身。那么最后一个节点执行第一次`cur++`，即cur记录的是倒数第几个节点。如果不是倒数第N个节点，那么就直接返回自己就行。然后一直返回到`cur=n`，也就是这个节点要删除，返回自身的下一个节点。

~~~c++
class Solution {
public:
    int cur = 0;
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(!head) return nullptr;
        head->next = removeNthFromEnd(head->next, n);
        cur++;
        if(n == cur){
            return head->next;
        }
        return head;
    }
};
~~~

#### [ 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

题目描述：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

思路：哨兵要的，而且哨兵还要分身，一直在进行交换的两个节点前面；交换时还要有tmp保存断开的节点。

~~~cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next){
            return head;
        }
        ListNode *preHead = new ListNode(-1);
        preHead->next = head;
        ListNode *node = preHead;
        while(node->next && node->next->next){
            ListNode *l1 = node->next;
            ListNode *l2 = node->next->next;
            ListNode *tmp = l2->next;
            l2->next = l1;
            l1->next = tmp;
            node->next = l2;
            node = l1;
        }
        return preHead->next;
    }
};
~~~



#### [两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

题目描述：给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 

进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

思路：尾对齐的，那么就要尾递归，或者用栈。这题题解只讲了栈。首先对两个链表分别入栈，然后从两个栈顶分别取元素，相加后的值作为新节点的值，并保存进位。

~~~cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> l1s = buildStack(l1);
        stack<int> l2s = buildStack(l2);
        ListNode *preHead = new ListNode(-1);
        int carry = 0;
        while(!l1s.empty() || !l2s.empty() || carry != 0){//注意carry != 0这个条件，避免5+5时，两个栈都空了，但是有进位。
            int x = l1s.empty() ? 0 : l1s.top();
            int y = l2s.empty() ? 0 : l2s.top(); 
            if(!l1s.empty()) l1s.pop();
            if(!l2s.empty()) l2s.pop();
            int sum = x + y + carry;
            ListNode *node = new ListNode(sum%10);
            node->next = preHead->next;
            preHead->next = node;
            carry = sum / 10;
        }
        return preHead->next;
    }
    stack<int> buildStack(ListNode* l){
        stack<int> s;
        while(l){
            s.push(l->val);
            l = l->next;
        }
        return s;
    }
};
~~~



#### [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

思路：整个流程可以分为以下五个步骤：

1. 找到前半部分链表的尾节点。使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。
2. 反转后半部分链表。
3. 判断是否回文。
4. 恢复链表。
5. 返回结果。

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 1. 辅助栈：先全部入栈，然后链表头和栈顶逐一比较
        // 2. 递归？递归时系统也会用栈，所以还是O(N)
        // 3. 快慢双指针：一个一步一个两步，找到中间然后翻转链表
        ListNode* slow = head, *fast = head,  *prev = nullptr;
        while(fast){//find mid node
            slow = slow->next;
            fast = fast->next ? fast->next->next : fast->next;// 若节点的next存在，则再走一步
        }
        // slow 指向中间节点
        while(slow){    //reverse
            ListNode* temp = slow->next;
            slow->next = prev;
            prev = slow;
            slow = temp;
        }
        while(head && prev){ //check
            if(head->val != prev->val){
                return false;
            }
            head = head->next;
            prev = prev->next;
        }
        return true;
    }
};
~~~



#### [分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)

描述：给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。

每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。

思路：注意要断链。

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        // 先计算清楚每段是多少个，用一个vector装着。无论如何都需要先遍历一次链表计数
        if(k==1) return vector<ListNode*>{head};
        
        int node_count = 0;
        ListNode* node = head;
        while(node){
            node_count++;
            node = node->next;
        }
        int base_num = node_count / k;
        int remainder = node_count % k;
        vector<int> counts(k, base_num);
        if(remainder != 0){
            for(int i = 0; i < remainder; i++){
                counts[i]++;
            }
        }
        vector<ListNode*> res;
        for(int i = 0; i < k; i++){
            res.emplace_back(head);
            cout << counts[i] << endl;
            for(int j = 0; j < counts[i] - 1; j++){
                head = head->next;
            }
            // 需要断开
            if(head){
                ListNode* tmp = head;
                head = head->next;
                tmp->next = nullptr;
            }
        }
        return res;
    }
};
~~~



#### [奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* odd = head;
        ListNode* evenHead = head->next;
        ListNode* even = evenHead;
        while(even && even->next){
            odd->next = even->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        }
        odd->next = evenHead;
        return head;
        
    }
};
~~~



## 树

### [递归](#递归)

#### [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

题目描述：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

思路：递归，分别找左右子树的最大深度。

~~~cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
~~~

#### [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

题目描述：给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

思路：用一个全局变量存结果，一旦遇到不平衡则修改结果。递归地找左右子树的最大深度，并比较最大深度的差。

~~~cpp
class Solution {
    bool res = true;
public:
    bool isBalanced(TreeNode* root) {
        maxDepth(root);
        return res;
    }
    int maxDepth(TreeNode* root){
        if(root == nullptr) return 0;
        int l = maxDepth(root->left);
        int r = maxDepth(root->right);
        if(abs(l - r) > 1){
            res = false;
        }
        return 1 + max(l, r);
    }
};
~~~

#### [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

题目描述：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

思路：分别找左右子树的最大深度，直径就是左子树深度加右子树深度的最大值。

~~~cpp
class Solution {
    int max_diameter = 0;
public:
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root);
        return max_diameter;
    }
    int depth(TreeNode* root){
        if(!root){
            return 0;
        }
        int l = depth(root->left);
        int r = depth(root->right);
        max_diameter = max(max_diameter, l + r);
        return max(l, r)+1;
    }
};
~~~

#### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

题目描述：左右翻转。

思路：左右子树执行swap。

~~~cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root){
            return nullptr;
        }
        //其实就是swap操作
        TreeNode* tmp = root->left;
        root->left = invertTree(root->right);
        root->right = invertTree(tmp);
        return root;
    }
};
~~~

#### [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

题目描述：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

思路：怎么保证在遍历同一个位置？应该想重新建一个树，而不是遍历原有的树，建树过程中，根据两个节点是否为空分四种情况。

~~~cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //递归基，三种情况
        if(!root1 && !root2) return nullptr;
        if(!root1) return root2;
        if(!root2) return root1;
        //建树的第四中情况，需要新建节点。
        TreeNode* node = new TreeNode(root1->val + root2->val);
        node->left = mergeTrees(root1->left, root2->left);
        node->right = mergeTrees(root1->right, root2->right);
        return node;
    }
};
~~~

#### [路径总和](https://leetcode-cn.com/problems/path-sum/)

题目描述：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

思路：递归基为：空指针返回false，叶子结点且节点值等于target返回true；减去target后递归左右子树。注意节点的值可能是负数。

~~~cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        //递归基
        if(!root) return false;
        if(!root->left && !root->right && targetSum == root->val) return true;
        bool l = hasPathSum(root->left, targetSum - root->val);
        bool r = hasPathSum(root->right, targetSum - root->val);
        return(l || r);
    }
};
~~~

#### [ 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

题目描述：给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

>
>
>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8
>
>      10
>     /  \
>    5   -3
>   / \    \
>  3   2   11
> / \   \
>3  -2   1
>
>返回 3。和等于 8 的路径有:
>
>1.  5 -> 3
>2.  5 -> 2 -> 1
>3.  -3 -> 11

思路：怎么往递归上靠？肯定要调用一个别的函数。

使用递归的方法有三个步骤

1. 明确函数作用
2. 做好递归基
3. 找到转换函数，缩小范围

对每个节点，有两种情况：1. 在这个节点为根节点的树中找路径，同时以该节点为起始节点 2. 在这个节点的子树中找。
因此，我们就可以写出代码，以该节点为起始的路径 + 子树中的路径



~~~cpp
class Solution {
public:
    int pathSum(TreeNode* root, int sum) {
        //递归基
        if(root == nullptr) return 0;
        //注意这里也有自己的递归，每个节点都作为根节点
        int ret = pathSumStartWithRoot(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);
        return ret;
    }
    int pathSumStartWithRoot(TreeNode* root, int sum){
        //递归基
        if(root == nullptr){
            return 0;
        }
        int ret = 0;
        if(root->val == sum){
            ret++;
        }
        //为什么都已经符合了，还要往下走？因为后面可能有两个节点和为0，同样满足题意
        //递归访问左右子树
        ret += pathSumStartWithRoot(root->left, sum - root->val) + pathSumStartWithRoot(root->right, sum - root->val);
        return ret;
    }
};
~~~

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

思路：递归分割左右子树，仔细计算后序遍历中，左右子树对应的下标位置。

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map<int, int> indexOfInorders;
    TreeNode* construct(int in_left, int in_right, int post_left, int post_right, vector<int>& inorder, vector<int>& postorder) {
        if (in_left > in_right) return nullptr;
        int root_val = postorder[post_right];
        TreeNode* root = new TreeNode(root_val);//后序遍历的最后一个值是root
        int root_index = indexOfInorders[root_val];
        cout << root_val << " ";
        int left_len = root_index - in_left;
        root->left = construct(in_left, root_index - 1, post_left, post_left + (root_index - in_left - 1), inorder, postorder);
        root->right = construct(root_index + 1, in_right, post_right - 1 - (in_right - root_index - 1), post_right - 1, inorder, postorder);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.size() == 0 || inorder.size() != postorder.size()){
            return NULL;
        }
        for (int i = 0; i < inorder.size(); i++) {
            indexOfInorders[inorder[i]] = i;
        }
        return construct(0, inorder.size()-1, 0, postorder.size()-1, inorder, postorder);
    }
};
~~~

#### [二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。

返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //递归在哈希中存每个节点的父节点，形成三叉树
    void findParent(TreeNode* node){
        //node为空时返回
        if(!node) return;
        //子节点存在时往下走
        if(node->left){
            parent[node->left] = node;
            findParent(node->left);
        }
        if(node->right){
            parent[node->right] = node;
            findParent(node->right);
        }
    }
    //注意防止往回走，要把自己传进去，用from表示来的路
    void dfs(TreeNode* node, TreeNode* from, int depth){
        //防止空指针
        if(!node) return;
        
        if(depth == 0){
            res.emplace_back(node->val);
            return;
        }
        if(node->left != from){
            dfs(node->left, node, depth-1);
        }
        if(node->right != from){
            dfs(node->right, node, depth-1);
        }
        if(parent[node] != from){
            dfs(parent[node], node, depth-1);
        }
    }
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        findParent(root);
        dfs(target, nullptr, k);
        return res;
        
    }
private:
    unordered_map<TreeNode*,TreeNode*> parent;//节点-父节点
    vector<int> res;
};
~~~

#### [二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) {
        //1.没有必要记录最小的值，因为最小的一定是根结点。 
        //2.递归找到比根结点大的值时可以立即返回，不用再遍历当前节点下面的子节点，因为子节点的值不可能比它小。
        return firstbigger(root, root->val);
    }
    int firstbigger(TreeNode* root, int val){
        if(!root) return -1;
        if(root->val > val) return root->val;
        int left = firstbigger(root->left, val);
        int right = firstbigger(root->right, val);
        if (left < 0) return right;
        if (right < 0) return left;
        return min(left,right);
    }
};
~~~

#### [求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。

计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum = 0;
    // int path_sum = 0;
    void fun(TreeNode* root, int path_sum){
        if(root == nullptr){
            return;
        }
        if(root->left == nullptr && root->right == nullptr){
            path_sum = path_sum*10 + root->val;
            sum += path_sum;
            cout << path_sum << endl;
            return;
        }
        fun(root->left, path_sum*10 + root->val);
        fun(root->right, path_sum*10 + root->val);    
    }
    int sumNumbers(TreeNode* root) {
        if(!root) return 0;
        fun(root, 0);
        return sum;
    }
};
~~~



### [层次遍历](#层次遍历)

#### [二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

思路：注意需要得到精确除法时，要将除数`double avg = double(level_sum) / size;`。同时累加防止溢出，用long。

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        // 层次遍历，用队列装一层，队列的大小控制层的切换
        if(!root) return{0.0};
        queue<TreeNode*> q;
        q.push(root);
        vector<double> res;
        while(!q.empty()){
            int size = q.size();
            long level_sum = 0;
            for(int i = 0; i < size; i++){
                TreeNode* node = q.front();
                q.pop();
                level_sum += node->val;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            double avg = double(level_sum) / size;
            res.push_back(avg);
        }
        return res;
    }
};
~~~



#### [找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

思路：层次遍历，用队列装一层，巧妙地从右到左，那么最左节点就是最后一个节点。

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        // 层次遍历，用队列装一层，巧妙地从右到左，那么最左节点就是最后一个节点。
        if(!root) return 0;
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* node;
        while(!q.empty()){
            node = q.front();
            q.pop();
            if(node->right) q.push(node->right);
            if(node->left) q.push(node->left);
        }
        return node->val;
    }
};
~~~



### [前中后序遍历](#前中后序遍历)

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
/*
递归法：
注意返回值是全局变量；
先输出，再访问左节点和右节点
*/
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(!root) return res;
        res.push_back(root->val);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
        return res;
    }
private:
    vector<int> res;
};

/*
迭代法
利用栈LIFO后进先出的特点，将根节点入栈后开始循环
输出栈顶元素，右节点、左节点依次入栈
*/
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> stk;
        if(root != NULL)
            stk.push(root);
        while(!stk.empty())
        {
            TreeNode* cur = stk.top();
            stk.pop();
            ans.push_back(cur->val);
            if(cur->right != NULL)
                stk.push(cur->right);
            if(cur->left != NULL)
                stk.push(cur->left);
        }
        return ans;
    }
};
~~~



#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
/*
递归
*/
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root) return res;
        inorderTraversal(root->left);
        res.push_back(root->val);
        inorderTraversal(root->right);
        return res;
    }
private:
    vector<int> res;
};
/*
迭代：
注意curr的赋值，找到第一条向左的路径后，继续找第二条向左路径，也就是逆向上来第一个有右节点的。
左链入栈
*/
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> s;
        TreeNode* curr = root;
        while(!s.empty() || curr != NULL)
        {
            // 找到节点的最左侧节点，同时记录路径入栈
            while(curr != NULL)
            {
                s.push(curr);
                curr = curr->left;
            }
            // top定义是此刻的弹栈元素
            TreeNode* top = s.top();
            res.push_back(top->val);
            s.pop();
            // 处理过最左侧结点后，判断其是否存在右子树
            if(top->right != NULL)
                curr = top->right;
        }
        return res;
    }
};

~~~



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    vector<int> postorderTraversal(TreeNode* root) {
        // 为空则直接返回
        if(root == NULL)
            return res;
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        res.push_back(root->val);
        return res;
    }
};
~~~



### BST

[1. 修剪二叉查找树](#1-修剪二叉查找树)

[2. 寻找二叉查找树的第 k 个元素](#2-寻找二叉查找树的第-k-个元素)

[3. 把二叉查找树每个节点的值都加上比它大的节点的值](#3-把二叉查找树每个节点的值都加上比它大的节点的值)

#### [4. 二叉查找树的最近公共祖先](#68.1 二叉搜索树的最近公共祖先)

#### [5. 二叉树的最近公共祖先](#68.2 普通二叉树的最近公共祖先)

[6. 从有序数组中构造二叉查找树](#6-从有序数组中构造二叉查找树)

[7. 根据有序链表构造平衡的二叉查找树](#7-根据有序链表构造平衡的二叉查找树)

[8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值](#8-在二叉查找树中寻找两个节点，使它们的和为一个给定值)

[9. 在二叉查找树中查找两个节点之差的最小绝对值](#9-在二叉查找树中查找两个节点之差的最小绝对值)

[10. 寻找二叉查找树中出现次数最多的值](#10-寻找二叉查找树中出现次数最多的值)

### [Trie](#trie)

#### [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

Trie树介绍

Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：

指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 ]children[0] 对应小写字母 aa，children[1] 对应小写字母 b，…，children[25] 对应小写字母 z。
布尔字段 isEnd，表示该节点是否为字符串的结尾。

##### 插入字符串

我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：

子节点存在。沿着指针移动到子节点，继续处理下一个字符。
子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。
重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。

##### 查找前缀

我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：

子节点存在。沿着指针移动到子节点，继续搜索下一个字符。
子节点不存在。说明字典树中不包含该前缀，返回空指针。
重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。

若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 isEnd 为真，则说明字典树中存在该字符串。

~~~c++

class Trie {
public:
    /** Initialize your data structure here. */
    Trie() : next(26), isEnd(false){}
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* node = this;
        for(char &c : word){
            // 节点不存在则新建节点
            if(node->next[c-'a'] == NULL){
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* node = this;
        for(char& c : word){
            node = node->next[c-'a'];
            if(node == NULL){
                return false;
            }
        }
        //因为这个节点可能不是结尾
        return node->isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* node = this;
        for(char& c : prefix){
            node = node->next[c-'a'];
            if(node == NULL){
                return false;
            }
        }
        return true;
    }

private:
    vector<Trie*> next;
    bool isEnd;
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
~~~



[1. 实现一个 Trie](#1-实现一个-trie)

[2. 实现一个 Trie，用来求前缀和](#2-实现一个-trie，用来求前缀和)

## 图

### 二分图

#### [判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

思路：我们知道如果是二分图的话，那么图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合。因此我们可以使用并查集来解决这个问题，我们遍历图中每个顶点，将当前顶点的所有邻接点进行合并，并判断这些邻接点中是否存在某一邻接点已经和当前顶点处于同一个集合中了，若是，则说明不是二分图。

~~~cpp
class UnionFind {
public:
    vector<int> parent;//下标是id，内容是父亲节点

    UnionFind(int n) {
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    //合并：先找到两个集合的代表元素，然后将前者的父节点设为后者即可
    void merge(int x, int y) {
        parent[find(y)] = find(x);
    }
    //路径压缩
    //把沿途的每个节点的父节点都设为根节点
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    bool isConnected(int x, int y){
        return find(x) == find(y);
    }
};
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        UnionFind uf(n);
        for(int i = 0; i < n; i++){
            for(auto node : graph[i]){
                if(uf.isConnected(i, node)){
                    return false;
                }
                uf.merge(graph[i][0], node);//以第一个邻接节点为根
            }
        }
        return true;
    }
};

~~~



### 并查集

[算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93647900/)

并查集模板：

~~~cpp
class UnionFind {
public:
    vector<int> parent;//下标是id，内容是父亲节点

    UnionFind(int n) {
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    //合并：先找到两个集合的代表元素，然后将前者的父节点设为后者即可
    void merge(int x, int y) {
        parent[find(y)] = find(x);
    }
    //路径压缩
    //把沿途的每个节点的父节点都设为根节点
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
};
~~~



#### [账户合并](https://leetcode-cn.com/problems/accounts-merge/)

~~~cpp
class UnionFind {
public:
    vector<int> parent;

    UnionFind(int n) {
        parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    //合并：先找到两个集合的代表元素，然后将前者的父节点设为后者即可
    void merge(int index1, int index2) {
        parent[find(index2)] = find(index1);
    }
    //路径压缩
    //把沿途的每个节点的父节点都设为根节点
    int find(int index) {
        if (parent[index] != index) {
            parent[index] = find(parent[index]);
        }
        return parent[index];
    }
};


class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        vector<vector<string>> res;
        unordered_map<string, int> email_id;//邮箱，账户id
        int n = accounts.size();
        UnionFind UF(n);//装的是账户id
        for(int i = 0; i < n; i++){
            int m = accounts[i].size();
            for(int j = 1; j < m; j++){
                string email = accounts[i][j];//第一个为人名，后面是邮箱地址
                if(email_id.find(email) == email_id.end()){//若邮箱地址不在map里
                    email_id[email] = i;
                }
                else{
                    UF.merge(i, email_id[email]);//合并，因为在i之前该邮箱地址已经出现过了
                }
            }
        }
        unordered_map<int, vector<string>> id_emails;
        for(auto& [key, value] : email_id){//还可以这样遍历一个map
            //对于每个email_id里的id，都找到相应的根节点，并把该邮箱加入到该id对应的邮箱列表里。
            id_emails[UF.find(value)].emplace_back(key);
        }
        //开始输出
        for(auto& [key, value] : id_emails){
            //value是一个邮箱列表
            sort(value.begin(), value.end());
            vector<string> tmp(1, accounts[key][0]);//人名
            tmp.insert(tmp.end(), value.begin(), value.end());
            res.push_back(tmp);
        }
        return res;
    }
};
~~~

#### [移除最多的同行或同列石头](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/)

思路：使用并查集，但输入数据是二维的，怎么处理？因为题目设定坐标最大值为10000，可以让y从10001开始，将二维压缩成一维。这样做是防止y的数值与x的数值相同时，被当做同行或同列处理。

parent不仅可以用`vector<int> parent;//下标是id，内容是父亲节点`，也可以用map。

~~~cpp
class UnionFind {
public:
    unordered_map<int, int> parent;
    int count;
    //这题不能在初始化时就建立对应的节点。因为输入是n，而映射到一维后有2n个节点
    UnionFind(int n):count(0) {}//初始化什么也不做
    
    //合并：先找到两个集合的代表元素，然后将前者的父节点设为后者即可
    void merge(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        if(rootx != rooty){//根节点不相同则进行合并，且集合-1
            parent[rootx] = rooty;
            count--;
        }
    }
    //路径压缩
    //把沿途的每个节点的父节点都设为根节点
    int find(int x) {
        if(parent.find(x) == parent.end()){
            parent[x] = x;
            count++;//新的集合
        }
        if (parent[x] != x) {
            parent[x] = find(parent[x]);//递归
        }
        return parent[x];
    }
    int get_count(){
        return count;
    }
};

class Solution {
public:
    int removeStones(vector<vector<int>>& stones) {
        int n = stones.size();
        UnionFind UF(n);
        for(auto& stone : stones){
            UF.merge(stone[0] + 10001, stone[1]);
        }
    return n - UF.get_count();
    }
};
~~~

### 拓扑排序

把一个 有向无环图 转成 线性的排序 就叫 拓扑排序。

#### [课程表](https://leetcode-cn.com/problems/course-schedule/)

![微信截图_20200517052852.png](https://gitee.com/Raymond-Z/typora/raw/master/image/20210416112610.png)

思路：维护一个入度数组，一个依赖关系map（课程id->依赖这门课的课程id），一个入度为0队列。根据依赖关系初始化入度数组和依赖关系map。

~~~cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> inDegree(numCourses);//入度
        unordered_map<int, vector<int>> map;//课程id->依赖这门课的课程id
        for (const auto& info: prerequisites) {
            //info[0],该门课，info[1]需要的先修课
            map[info[1]].push_back(info[0]);
            ++inDegree[info[0]];
        }
        //入度为0的先入队
        queue<int> q;
        for (int i = 0; i < numCourses; ++i) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        int count = 0;
        while(!q.empty()){
            int selected = q.front();q.pop();
            count++;
            for(auto& c : map[selected]){
                //因为该门课程修完了，依赖这门课的课程入度统统-1；
                inDegree[c]--;
                //如果入度为0，那么入队
                if(inDegree[c] == 0){
                    q.push(c);
                }
            }
        }
        return count == numCourses;
    }
};
~~~

#### [课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

~~~cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> inDegree(numCourses);//入度
        unordered_map<int, vector<int>> map;//课程id->依赖这门课的课程id
        for (const auto& info: prerequisites) {
            //info[0],该门课，info[1]需要的先修课
            map[info[1]].push_back(info[0]);
            ++inDegree[info[0]];
        }
        //入度为0的先入队
        queue<int> q;
        for (int i = 0; i < numCourses; ++i) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        int count = 0;
        vector<int> res;
        while(!q.empty()){
            int selected = q.front();q.pop();
            res.push_back(selected);
            count++;
            for(auto& c : map[selected]){
                //因为该门课程修完了，依赖这门课的课程入度统统-1；
                inDegree[c]--;
                //如果入度为0，那么入队
                if(inDegree[c] == 0){
                    q.push(c);
                }
            }
        }
        return res.size() == numCourses ? res : vector<int>{};
    }
};
~~~



# LeetCode做题笔记

#### [115. 不同的子序列-腾讯](https://leetcode-cn.com/problems/distinct-subsequences/) 

题目描述：给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

思路：用一个哈希表记录 t中每个字母在s中出现的位置，得到一个行为升序的二维数组。然后用回溯法，在二维数组中的每一行取一个元素，构成一个上升序列。以下代码逻辑是通的，就是当t稍微长点，循环就会更深，所以超时。

~~~cpp
class Solution {
public:
    int res = 0;
    int numDistinct(string s, string t) {
        unordered_map<char, vector<int>> map;//key是t中的每个char，value是在s中的下标，且value是有序的
        for(auto c : t){
            map[c] = {};
        }
        for(int i = 0; i < s.size(); i++){
            if(map.find(s[i]) != map.end()){//能在s里找到t字母
                map[s[i]].push_back(i);
            }
        }
        //检查是不是都有
        for(auto it : map){
            if(it.second.size() == 0){
                return 0;
            }
        }
        //开始回溯，
        backtracking(t, map, 0, -1);
        return res;
    }
    void backtracking(string& t, unordered_map<char, vector<int>>& map, int cur_size, int pre_index){
        
        if(cur_size == t.size()){
            res++;
            cout << res << endl;
            return;
        }
        for(int cur_index : map[t[cur_size]]){
            if(pre_index > map[t[cur_size]].back()){
                return;
            }
            if(cur_index > pre_index){
                cout << pre_index << "," << cur_index << "," << cur_size << endl;
                backtracking(t, map, cur_size+1, cur_index);
            }
        }

    }
};
~~~

动态规划思路：

1. 开辟空间。遇到两个字符串的，就开一个二维的dp数组。`dp[n+1][m+1]`,其中n是t的长度，m是s的长度。`dp[i][j]表示s的前j个字符构成的字符串的子序列中出现t的前i个字符构成的字符串的个数`

2. 初始状态。n为0时代表t为空字符串；`dp[i][0]表示在一个空字符串的子序列中出现某个非空字符串的个数, 易知dp[i][0] = 0;`m为0时代表s为空字符串，`dp[0][j]表示在一个字符串的子序列中出现空字符串的个数, 易知dp[0][j] = 1;`特别地，`dp[0][0]=1`表示空字符串里有空字符的个数。
3. 转移方程，可以写一个找找规律。文字描述是，上面一格代表`t[0:i-1]在s[0:j]中子序列的个数`，左边一格代表`t[0:i]在s[0:j-1]中子序列的个数`。当i不变j变大时，会有两种情况：`t[i]==s[j] || t[i]!=s[j]`。两者相等时，在`上面t[0:i-1]的基础上，加上这次左边`
4. ![image-20210316225453407](https://gitee.com/Raymond-Z/typora/raw/master/image/20210316225454.png)

~~~cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size(), n = t.size();
        if(m < n) return 0;
        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        for(int j = 0; j <= m; j++){
            dp[0][j] = 1;
        }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(s[j-1] == t[i-1]){
                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1];
                }
                else{
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        return dp[n][m];
    }
};
~~~

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

描述：给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

动态规划思路：

**初始状态**：

- `dp[i][j]=1; //单个字符是回文串`
- `dp[i][j]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串`
- `dp[i][j] = (s[i] == s[j] && dp[i+1][j-1]);`
- 外层长度循环，内层起始循环

~~~cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n <= 1) return s;
        string res;
        vector<vector<int>> dp(n, vector<int>(n));//bool 值的本质上就是一个整数值。
        for(int l = 0; l < n; ++l){//长度遍历
            for(int i = 0; i + l < n; ++i){//起始遍历
                int j = i + l;//这里要考虑，如果l最小为l，那么j为开区间
                if(l > 1){//把最有可能的放前面
                    dp[i][j] = (s[i] == s[j] && dp[i+1][j-1]);
                }
                else if(l == 1){
                    dp[i][j] = (s[i] == s[j]);
                }
                else{// l == 1
                    dp[i][j] = 1;
                }
                if(dp[i][j] && l + 1 > res.size()){//更新答案
                    res = s.substr(i, l + 1);
                }
            }
        }
        return res;
    }
};
~~~

复杂度分析

时间复杂度：O(n^2)，其中 nn 是字符串的长度。动态规划的状态总数为 O(n^2),对于每个状态，我们需要转移的时间为 O(1)。

空间复杂度：O(n^2),即存储动态规划状态需要的空间

中心扩展法：方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。

~~~cpp
class Solution {
public:
    pair<int, int> expandAroundCenter(const string& s, int left, int right) {
        while (left >= 0 && right < s.size() && s[left] == s[right]) {
            --left;
            ++right;
        }
        return {left + 1, right - 1};
    }

    string longestPalindrome(string s) {
        int start = 0, end = 0;
        for (int i = 0; i < s.size(); ++i) {
            auto [left1, right1] = expandAroundCenter(s, i, i);
            auto [left2, right2] = expandAroundCenter(s, i, i + 1);
            if (right1 - left1 > end - start) {
                start = left1;
                end = right1;
            }
            if (right2 - left2 > end - start) {
                start = left2;
                end = right2;
            }
        }
        return s.substr(start, end - start + 1);
    }
};
~~~

#### [和为K的子数组-tx](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

描述：给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

思路：暴力法，从前往后遍历i作为终点，从i往前遍历j作为起点，这样得到` [j,i]`子数组的和。超时

~~~cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int count = 0;
        for(int i = 0; i < nums.size(); i++){
            int sum = 0;
            for(int j = i; j >= 0; j--){
                sum += nums[j];
                if(sum == k){
                    count++;
                }
            }
        }
        return count;
    }
};
~~~

思路2：前缀和+哈希。引入前缀和的概念，则`「[j..i] 这个子数组和为 k 」`条件为`pre[i]−pre[j−1]==k`，即`pre[j−1]==pre[i]−k`。那么从前往后遍历，哈希表以和为键，出现次数为对应的值。当能在哈希表中找到相应的`pre[j−1]`时，即证明该段子数组和为k。

~~~cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        int count = 0, pre = 0;
        map[0] = 1;
        for(auto num : nums){
            pre += num;
            if(map.find(pre - k) != map.end()){
                count += map[pre - k];
            }
            map[pre]++;
        }
        return count;
    }
};
~~~

#### [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)

描述：给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。由于答案可能很大，因此 返回答案模 10^9 + 7 。

思路：找到数组中的每一个数作为最小值的范围，比如对于某个数nums[i]能够最小值以这种形式表示：左边连续m个数比nums[i]大，右边连续n个数比nums[i]大。

那么以nums[i]为最小值的子数组的个数是`(m+1)(n+1)`.

维护一个单调递增栈, 存储的是数组A的索引；每个元素都要入栈，当出栈的时候计算A[i]属于的区间：出栈元素和栈顶元素之间都比出栈元素大，当前要入栈元素与出栈元素之间都比出栈元素大。

~~~cpp
class Solution {
    const int mod = 1e9 + 7;
public:
    int sumSubarrayMins(vector<int>& arr) {
        stack<int> st;//存下标的单调递增栈
        arr.push_back(-1);//保证数组里每个数都能弹出
        int n = arr.size();
        int res = 0;
        for(int i = 0; i < n; ++i){
            while(!st.empty() && arr[i] < arr[st.top()]){//遇到当前元素比栈顶元素小的，要把栈顶依次弹出才能把当前元素入栈
                int index = st.top();
                st.pop();
                int pre = index - (st.empty()? -1 : st.top());//m+1
                int after = i - index;//n-1
                res += long(arr[index]) * pre * after % mod;
                res %= mod;
            }
            st.push(i);
        }
        return res;
    }
};
~~~

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

描述：请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

思路：找后面比当前大的第一个元素。每个元素都入栈，当后面大时出栈。所以维护的是单调递减栈，存的是下标。

~~~cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        vector<int> res(T.size());
        T.push_back(0);//保证全部出栈
        int n = T.size();
        stack<int> st;
        for(int i = 0; i < n; i++){
            while(!st.empty() && T[i] > T[st.top()]){
                int index = st.top();
                st.pop();
                res[index] = i - index;//当前出栈元素与要入栈元素的距离
            }
            st.push(i);
        }
        return res;
    }
};
~~~

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

描述：一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。

思路：和打家劫舍I一样，不能选择相邻的两个节点。所以对于一个子树来说，有两种情况：

1. 包含当前根节点
2. 不包含当前根节点

1. 情况1：包含根节点
   由于包含了根节点，所以不能选择左右儿子节点，这种情况的最大值为：当前节点 + 左儿子情况2 + 右二子情况2
2. 情况2：不包含根节点
   这种情况，可以选择左右儿子节点，所以有四种可能：
   1. 左儿子情况1 + 右儿子情况1
   2. 左儿子情况1 + 右儿子情况2
   3. 左儿子情况2 + 右儿子情况1
   4. 左儿子情况2 + 右儿子情况2

综合来说就是，max(左儿子情况1, 左儿子情况2) + max(右儿子情况1, 右儿子情况2)。

综合两种情况，深度优先，从叶子节点遍历到根节点即可。

由于只有两种情况，可以选择使用pair来存储这两种情况的数据值。pair的含义：<情况1包含当前节点的最大值，情况2不包含当前节点的最大值>

~~~cpp
class Solution {
public:
    pair<int, int> dfs(TreeNode* root){
        if(!root) return{0, 0};//递归基
        auto left_pair = dfs(root->left);
        auto right_pair = dfs(root->right);
        return{root->val + left_pair.second + right_pair.second, max(left_pair.first, left_pair.second) + max(right_pair.first, right_pair.second)};
        //返回是个pair，first是情况1包含当前节点的最大值，当前节点 + 左儿子情况2 + 右二子情况2；second是不包含当前节点的最大值，max(左儿子情况1, 左儿子情况2) + max(右儿子情况1, 右儿子情况2)。
    }

    int rob(TreeNode* root) {
        auto p = dfs(root);
        return max(p.first, p.second);
    }
};
~~~

#### [1743. 从相邻元素对还原数组](https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/)

描述：存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。

给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。

题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。

返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。



思路：想用map来存关系，但是会存在键的重复，如2>1,3->4,然后2->3时就重复了。这是因为map需要声明为`map<int, vector<int>>`,就可以存两边的了。然后找到值都得长度为1的就是首尾，选择一个开始单向构造。

~~~c++
class Solution {
public:
    vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
        //用map存所有关系
        unordered_map<int, vector<int>> map;
        for(auto pair : adjacentPairs){
            map[pair[0]].push_back(pair[1]);
            map[pair[1]].push_back(pair[0]);
        }
        //找value大小为1的，即为首尾。
        int l = 0;
        for(auto iter : map){
            if(iter.second.size() == 1){
                l = iter.first;
            }
        }
        vector<int> res(adjacentPairs.size()+1);
        res[0] = l;
        res[1] = map[res[0]][0];
        for(int i = 2; i < res.size(); i++){
            res[i] = map[res[i-1]][0] !=  res[i-2] ? map[res[i-1]][0] : map[res[i-1]][1];
        }
        return res;
    }
};
~~~

## 树

#### [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

描述：给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。

思路：递归在哈希中存每个节点的父节点，形成三叉树。再从target 开始做dfs，但要注意避免往回走。

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //递归在哈希中存每个节点的父节点，形成三叉树
    void findParent(TreeNode* node){
        //node为空时返回
        if(!node) return;
        //子节点存在时往下走
        if(node->left){
            parent[node->left] = node;
            findParent(node->left);
        }
        if(node->right){
            parent[node->right] = node;
            findParent(node->right);
        }
    }
    //注意防止往回走，要把自己传进去
    void dfs(TreeNode* node, TreeNode* from, int depth){
        //防止空指针
        if(!node) return;
        
        if(depth == 0){
            res.emplace_back(node->val);
            return;
        }
        if(node->left != from){
            dfs(node->left, node, depth-1);
        }
        if(node->right != from){
            dfs(node->right, node, depth-1);
        }
        if(parent[node] != from){
            dfs(parent[node], node, depth-1);
        }
    }
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        findParent(root);
        dfs(target, nullptr, k);
        return res;
        
    }
private:
    unordered_map<TreeNode*,TreeNode*> parent;//节点-父节点
    vector<int> res;
};
~~~



# 剑指offer题解

## 数组与矩阵

#### [3. 数组中重复的数字](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

但是如果要求时间复杂度 O(N)，空间复杂度 O(1)。则不能使用排序的方法，也不能使用额外的标记数组。

思路：第一思路哈希表。没有就插入，有就返回。

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。也就是partition算法的变体。

~~~cpp
class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) {
        for(int i = 0; i < length; i++){
            if(numbers[i] == i){
                continue;
            }
            if(numbers[i] != numbers[numbers[i]]){
                swap(numbers[i], numbers[numbers[i]]);
            }
            else{
                duplication[0] = numbers[i];
                return true;
            }
        }
        return false;
    }
};
~~~



#### [4. 二维数组中的查找](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

[C/C++二维数组总结_哆啦A瑶的博客-CSDN博客_c++ 二维数组](https://blog.csdn.net/qq_26822029/article/details/85037209)

思路：从左上角找好像不好，有歧义。从右上角开始，大了往左，小了往下

~~~cpp
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int rows = array.size(), cols = array[0].size();
        int i = 0, j = cols - 1;
        while(i < rows && j >= 0){
            if(array[i][j] == target){
                return true;
            }
            array[i][j] < target ? i++ : j--;
        }
        return false;
    }
};
~~~



#### [5. 替换空格](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

思路：最方便当然是replace了，但是这种题不能这么做。用一个字符串暂存也容易想到，但是需要原地吗？**这种字符串复制的要想到从后向前的遍历。**

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7c1fea2-c1e7-4d31-94b5-0d9df85e093c.gif" width="350px"> </div><br>

双指针，遍历两次。第一次确定替换后的字符串长度，从前向后遍历，每遇到一个空格就在字符串末尾加两个格；第二次从后向前遍历，p1指向原字符串结尾，p2指向新字符串结尾，同时向前走，p1如果遇到字母就复制，遇到空格则p2插入`%20`(逆序)。直到p1和p2相遇。

[C++ char【】和char* - Fflyqaq - 博客园 (cnblogs.com)](https://www.cnblogs.com/Fflyqaq/p/12002635.html)

[常量指针和指针常量的区别_weibo_dm的博客-CSDN博客_常量指针和指针常量的区别](https://blog.csdn.net/weibo_dm/article/details/80445205)

所以`char *str`是可以直接访问原长度后面的空间？

`while`循环里面`p1 >= 0`是怎么实现剪枝的？

~~~cpp
class Solution {
public:
	void replaceSpace(char *str,int length) {
        if(str == nullptr || length <= 0) return;
        int cnt = 0;
        for(int i = 0; i < length; i++){
            if(str[i] == ' '){
                cnt++;
            }
        }
        if(cnt == 0) return;
        int p2 = length - 1 + 2 * cnt;
        int p1 = length - 1;
        while(p1 >= 0 && p1 < p2){
            if(str[p1] == ' '){
                str[p2--] = '0';
                str[p2--] = '2';
                str[p2--] = '%';
            }
            else{
                str[p2--] = str[p1];
            }
            p1--;
        }
	}
};
~~~

#### [13.调整数组顺序使奇数位于偶数前面](https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=13&&tqId=11166&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

题目描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

思路：很容易想到两次遍历，一次找奇数第二次找偶数。时间复杂度也是O(N)

~~~c++
class Solution {
public:
    vector<int> reOrderArray(vector<int>& array) {
        // write code here
        vector<int> res;
        for(int a : array){
            if((a&1)==1){
                res.push_back(a);
            }
        }
        for(int a : array){
            if((a&1)!=1){
                res.push_back(a);
            }
        }
        return res;
    }
};
~~~

#### [28. 数组中出现次数超过一半的数字](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&&tqId=11181&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

思路：哈希法：哈希统计每个数出现的次数，当当前访问的数字的出现次数大于一半即可停止。
        	排序法：排序后，中位数即为出现超过一半的数字
        	摩尔投票法：一次遍历，记录一个candidate和count；当count为0时，candidate=x，非0时判断candidate和x是否相等。若相等则count++，否则--；

以下为摩尔投票法：

~~~c++
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {

        int count = 1, candidate = numbers[0];
        for(int i = 1; i < numbers.size(); i++){
            if(count == 0){
                candidate = numbers[i];
                ++count;
                continue;
            }
            if(candidate == numbers[i]){
                ++count;
            }
            else{
                --count;
            }
        }
        return candidate;
    }
};
~~~



#### [29. 顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

思路：难点是边界的处理。用四个变量指定四个边界

~~~cpp
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        int top = 0, bottom = matrix.size()-1, left = 0, right = matrix[0].size()-1;
        vector<int> res;
        while(left <= right && top <= bottom){
            //上，从left到right
            for(int i = left; i <= right; i++){
                res.push_back(matrix[top][i]);
            }
            //右，从top到bottom
            for(int i = top+1; i <= bottom; i++){
                res.push_back(matrix[i][right]);
            }
            //下，从right到left
            if(top != bottom){
                for(int i = right-1; i >= left; i--){
                    res.push_back(matrix[bottom][i]);
                }
            }
            //左，从bottom到top
            if(left != right){
                for(int i = bottom-1; i > top; i--){//因为top访问过了
                    res.push_back(matrix[i][left]);
                }
            }
            top++;
            right--;
            bottom--;
            left++;
        }
        return res;
    }
};
~~~

#### [37. 数字在升序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&&tqId=11190&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

思路：分别用二分查找，找到这个数字的上下界。

二分查找要多记忆一下。

~~~c++
class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) {
        return upper_bound(data.begin(), data.end(), k) - lower_bound(data.begin(), data.end(), k);
    }
};
~~~



~~~c++
class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) {
        //二分找第一个的下标，二分找最后一个的下标，然后相减
        int l = 0, h = data.size();
        while(l < h){
            int mid = l + (h - l)/2;
            if(data[mid] < k) l = mid + 1;
            else h = mid;
        }
//         int l_index = data[l+1] == k ? l+1 : -1;
        int l_index = l;
        cout<<l_index<<endl;
        l = 0, h = data.size();
        while(l < h){
            int mid = l + (h - l)/2;
            if(data[mid] <= k) l = mid + 1;
            else h = mid;
        }
//         int h_index = data[l] == k ? l : -1;
        int h_index = l;
        cout<<h_index<<endl;
        return h_index - l_index;
    }
};
~~~



#### [50. 第一个只出现一次的字符位置](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）。

思路：桶计数。

~~~cpp
class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        int n = str.size();
        if(n <= 1){
            return n-1;
        }
        unordered_map<char, int> map;//字母，次数
        for(char c : str){
            if(map.find(c) == map.end()){
                map[c] = 1;
            }
            else{
                map[c] ++;
            }
        }
        for(int i = 0; i < n; i++){
            if(map[str[i]] == 1){
                return i;
            }
        }
        return -1;
    }
};
~~~

优化：考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。

以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。

## 栈队列堆

#### [9. 用两个栈实现队列](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&&tqId=11158&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

思路：FIFO和FILO的区别，只需要将全体数据搬运一次就可以。

~~~c++
class Solution
{
public:
    void push(int node) {
        //push操作就直接往stack1中push
        stack1.push(node);
    }

    int pop() {
        //pop操作需要分类一下：
        //如果stack2为空，那么需要将stack1中的数据转移到stack2中，然后在对stack2进行pop
        //如果stack2不为空，直接pop就ok。
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int res = stack2.top();
        stack2.pop();
        return res;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
~~~

#### [20. 包含min函数的栈（最小栈）](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&&tqId=11173&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)。

思路：思考用什么数据结构存储min所需要的信息。

用一个值记录：min该怎么实现呢，每次push和pop都要刷新。无法实现。

用一个同等大小的栈记录min：

~~~c++
class Solution {
public:
    void push(int value) {
        val.push(value);
        if(min_val.empty()){
            min_val.push(value);
        }
        else{
            if(value < min_val.top()){
                min_val.push(value);
            }
            else{
                min_val.push(min_val.top());
            }
        }
    }
    void pop() {
        val.pop();
        min_val.pop();
    }
    int top() {
        return val.top();
    }
    int min() {
        return min_val.top();
    }
private:
    stack<int> val;
    stack<int> min_val;
};
~~~

解法2，不使用额外空间。但是如果stack声明为`stack<long>`，那和用两个`stack<int>`不是一样吗？

~~~c++
class MinStack {
public:
    /** initialize your data structure here. 
    此算法最精髓的是，pop时，栈中的值若是负数，那么栈顶元素就是最小值，且最小值会发生变化，要用当前的最小值-栈顶元素才获得新的最小值。
    若是正数，那么栈顶的值就是当前栈顶值 + 最小值。*/
    /**
     * stack用来存储和min的差值，min存储最小值，每次出栈的时候通过差值和当前min计算要出栈的值和之前的min
     * 如果差值diff大于等于0，说明要出栈的值大于等于当前min，那么要出栈的值在入栈的时候没有更新min，返回min+diff；
     * 如果插值diff小于0，说明当前要出栈的值就是min(因为入栈的时候我们选择的就是min和入栈元素的最小值)，同时，通过min-diff计算出之前min
     * 要注意的是diff可能会超出int范围，类似于 Integer.MAX_VALUE - 1 这种，所以diff要用Long存
     */
    
    
    /*
    栈中存的是当前值与入栈前最小值的差值
    */
    stack<long> s;
    long min_val = -1;
    long long diff;
    MinStack() {
    }
   
    void push(int val) {
        if(s.empty()){
            s.push(0);
            min_val = val;
        }
        else{
            diff = val - min_val;
            // diff > 0 代表 val > min_val
            min_val = diff > 0 ? min_val : val;
            s.push(diff); //存当前值与入栈前最小值的差值
        }
    }
    
    void pop() {
        diff = s.top();
        int top = min_val;
        // 如果diff < 0，代表即将弹栈的元素是最小值
        if(diff < 0){
            //更新最小值
            min_val = top - diff;
        }
        s.pop();
    }
    
    int top() {
        diff = s.top();
        if(diff < 0){
            return min_val;
        }
        return diff + min_val;
    }
    
    int getMin() {
        return min_val;
    }
};
~~~



#### [31. 栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：使用一个栈来模拟压入弹出操作。每次入栈一个元素后，都要判断一下栈顶元素是不是当前出栈序列，如果是的话则执行出栈操作并将 popSequence 往后移一位，继续进行判断。

~~~cpp
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        stack<int> st;
        
        int i = 0, j = 0;
        while(i < pushV.size()){
            st.push(pushV[i]);
            while(!st.empty() && st.top() == popV[j]){
                st.pop();
                j++;
            }
            i++;
        }
        return st.empty();
    }
};
~~~



#### [40. 最小的 K 个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

题目描述：输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

思路：堆排序，或者快排。

快速排序：直接通过快排切分排好第 K 小的数（下标为 K-1），那么它左边的数就是比它小的另外 K-1 个数。

~~~cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        if(arr.size() == 0 || k <= 0){
            return {};
        }
        return quickSearch(arr, 0, arr.size(), k-1);
    }
    vector<int> quickSearch(vector<int>& nums, int lo, int hi, int k){//待查找数组，起止范围[)，要找的下标
        int j = partition(nums, lo, hi);
        if(j == k){
            return vector(nums.begin(), nums.begin() + k + 1);//因为k是下标，且返回是[)，所以需要+1
        }
        return j > k ? quickSearch(nums, lo, j, k) : quickSearch(nums, j+1, hi, k);
    }
    int partition(vector<int>& nums, int lo, int hi){
        swap(nums[lo], nums[lo + rand() % (hi - lo)]);//随机交换
        int pivot = nums[lo];//经过以上交换，等效于随机选取轴点
        hi--;//从[)变[]
        while(lo < hi){//从两端交替向中间扫描，彼此靠拢
            while(lo < hi && pivot <= nums[hi]) hi--;//向左拓展G 
            nums[lo] = nums[hi];//凡小于轴点，归入L
            while(lo < hi && nums[lo] <= pivot) lo++;//向右拓展L 
            nums[hi] = nums[lo];//凡大于轴点，归入G
        }//assert: lo == hi
        nums[lo] = pivot;//候选轴点归位
        return lo;
    }
};
~~~

堆排序：

~~~cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> res(k, 0);
        if(arr.size() == 0 || k == 0) return res;
        priority_queue<int> Q;//优先队列,C++为大根堆，即top是最大元素。
        for(int i=0; i<k; i++){
            Q.push(arr[i]);//前K个数入队
        }
        for(int i=k; i<arr.size(); i++){//剩余元素经过大根堆处理
            if(Q.top() > arr[i]){//当前元素小于堆中的最大值
                Q.pop();
                Q.push(arr[i]);
            }
        }
        for(int i=0; i<k; i++){//输出堆中元素
            res[i] = Q.top();
            Q.pop();
        }
        return res;
    }
};
~~~



[41.1 数据流中的中位数](41.1%20数据流中的中位数.md)

[41.2 字符流中第一个不重复的字符](41.2%20字符流中第一个不重复的字符.md)

#### [64. 滑动窗口的最大值](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&&tqId=11217&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。

思路：暴力法 O(NK)
        	构建大小为K的大顶堆，O(nlogk)【似乎不太好做，因为堆只有删除对顶元素的操作，没法删指定值】
      	  构建大小为K的单调下降队列：队列为空时入队，非空时比较当前元素n和队尾元素，如果n较大，则删去队尾元素；

~~~c++
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size) {
        //暴力法 O(NK)
        //构建大小为K的大顶堆，O(nlogk)
        //构建大小为K的单调下降队列：队列为空时入队，非空时比较当前元素n和队尾元素，如果n较大，则删去队尾元素；
        int n = num.size();
        if(size > n || num.empty() || size < 1) return {};
        vector<int> res;
        deque<int> dq;//dq存的是下标
        for(int i = 0; i < n; ++i){
            while(!dq.empty() && num[dq.back()] < num[i]){
                dq.pop_back();
            }
            dq.push_back(i);
            //队首的下标加上长度仍小于当前下标，即为过期
            if(dq.front() + size <= i){
                dq.pop_front();
            } 
            //因为下标从0开始，若当前下标大于等于size，则已经构成窗口
            if(i + 1 >= size){
                //单调下降队列，队首元素即为最大值
                res.push_back(num[dq.front()]);
            }
        }
        return res;
    }
};
~~~



## 双指针

#### [57.1 和为 S 的两个数字](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

描述：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

思路：乘积最小就是两个数差距越大。

~~~cpp
class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum) {
        int lo = 0, hi = array.size() - 1;
        while(lo < hi){
            int tmp_sum = array[lo] + array[hi];
            if(tmp_sum == sum){
                vector<int> res;
                res.push_back(array[lo]);
                res.push_back(array[hi]);
                return res;
            }
            else if(tmp_sum < sum){
                lo++;
            }
            else{
                hi--;
            }
        }
        return {};
    }
};
~~~



#### [57.2 和为 S 的连续正数序列](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

描述：输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序

思路：双指针，区间和大了slow往前走，区间和小了fast往前走；遇到答案后，slow和fast都往前走。走到哪呢？走到sum。

时间复杂度：O(N)

空间复杂度：O(1)

~~~cpp
class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
        int fast = 2, slow = 1, cur_sum = 3;
        vector<vector<int> > res;
        while(fast < sum){
            if(cur_sum > sum){
                cur_sum -= slow;
                slow++;
            }
            else if(cur_sum < sum){
                fast++;
                cur_sum += fast;
                
            }
            else{
                vector<int> tmp;
                for(int i = slow; i <= fast; i++){
                    tmp.push_back(i);
                }
                res.push_back(tmp);
                cur_sum -= slow;
                slow++;
                fast++;
                cur_sum += fast;
            }
        }
        return res;
    }
};
~~~



#### [58.1 翻转单词顺序列](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：遇到空格或标点就整体翻转。可以翻转两次：`ab abc bcd -> dcb cba ba -> bcd abc ab`，第一次整体翻转，第二次单词翻转。

~~~cpp
class Solution {
public:
    string ReverseSentence(string str) {
        reverse(str.begin(), str.end());
        int i = 0, j = 0, n = str.size();
        while(j <= n){
            if(str[j] == ' ' || j == n){
                reverse(str.begin()+i, str.begin()+j);
                i = j+1;
            }
            j++;
        }
        return str;
    }
};
~~~



#### [58.2 左旋转字符串](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：上面一题的特殊情况。上一题是每个单词都翻转，这个是按位数翻转。先按单词翻转，再整体翻转

~~~cpp
class Solution {
public:
    void reverse(string& str, int l, int r){
        while(l < r){
            swap(str[l++], str[r--]);
        }
    }
    string LeftRotateString(string str, int n) {
        if(str.empty()){
            return str;
        }
        reverse(str, 0, n-1);
        reverse(str, n, str.size()-1);
        reverse(str, 0 , str.size()-1);
        return str;
    }
};
~~~



## 链表

#### [6. 从尾到头打印链表](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

递归：不使用std::reverse()。

~~~c++
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        if(!head){
            return res;
        }
        res = printListFromTailToHead(head->next);
        res.push_back(head->val);
        return res;
    }
};
~~~

遍历：使用reverse()

~~~c++
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        while(head){
            res.push_back(head->val);
            head = head->next;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
~~~

#### [14. 链表中倒数最后k个结点](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&&tqId=11167&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

题目描述：输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。如果该链表长度小于k，请返回一个长度为 0 的链表。

思路：暴力法，数节点个数后，再从头走一次。

双指针法：快指针先走k步，然后快慢一起走到末位。

使用栈：节点全部压栈，然后出栈第k个。

递归方法：不太好想。终止条件是null。

递归法：

~~~c++
public ListNode getKthFromEnd(ListNode head, int k) {
    //终止条件
    if (head == null)
        return head;
    //递归调用
    ListNode node = getKthFromEnd(head.next, k);
    //逻辑处理
    ……
}
~~~

~~~c++
int size;

public ListNode FindKthToTail(ListNode pHead, int k) {
    if (pHead == null)
        return pHead;
    ListNode node = FindKthToTail(pHead.next, k);
    if (++size == k)
        return pHead;
    return node;
}
~~~

双指针法：

~~~c++
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        ListNode *fast = pHead;
        for(int i = 0; i < k; i++){
            if(fast == nullptr){
                return nullptr;
            }
            fast = fast->next;
        }
        ListNode *slow = pHead;
        while(fast != nullptr){
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
~~~



#### [18.2 删除链表中重复的结点](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：有重复的全部删除

遍历思路：首先定义哨兵节点，用来最后返回；然后定义两个节点用来遍历；分有重复和无重复两种情况，有重复要注意两个以上重复的情况。

~~~c++
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead) {
        if (pHead == NULL || pHead->next == NULL) { // 只有0个或1个节点
            return pHead;
        }
        ListNode* preHead = new ListNode(-1);
        preHead->next = pHead;
        ListNode* pre = preHead;
        ListNode* cur = pHead;
        while(cur){
            if(cur->next && cur->val == cur->next->val){//有重复
                cur = cur->next;//先删除第一个重复的
                while(cur->next && cur->val == cur->next->val){//两个以上的重复，删除中间的重复
                    cur = cur->next;
                }
                cur = cur->next;//删除最后一个重复
                pre->next = cur;
            }
            else{//没有重复或者到结尾
                pre = cur;
                cur = cur->next;
            }
        }
        return preHead->next;
    }
};
~~~

递归思路：拿到一个节点判断是否重复，重复则找到第一个与当前节点不同的节点A，以A为输入继续找，返回结果；如果不重复则以下一个节点为输入处理后面，返回当前节点。

~~~c++
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead) {
        if (pHead == NULL || pHead->next == NULL) { // 只有0个或1个节点
            return pHead;
        }
        ListNode* next = pHead->next;
        if(pHead->val == next->val){
            while(next != NULL && next->val == pHead->val){
                // 跳过值与当前节点相同的全部节点，找到第一个与当前节点不同的节点
                next = next->next;
            }
            return deleteDuplication(next);
        }
        else{
            pHead->next = deleteDuplication(pHead->next);
            return pHead;
        }
    }
};
~~~



#### [22. 链表中倒数第 K 个结点](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：要想到快慢双指针。

~~~C++
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        if(!pListHead || k<0){
            return NULL;
        }
        ListNode* fast = pListHead;
        while(k--){
            if(fast){
                fast = fast->next;
            }
            else{
                return NULL;
            }
        }
        ListNode* slow = pListHead;
        while(fast != NULL){
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
~~~



#### [23. 链表中环的入口结点](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

双O(n)方法：哈希表。

牛客网有点傻

~~~c++
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        unordered_set<ListNode*> set;
        while(pHead){
            if(set.find(pHead) == set.end()){
                set.insert(pHead);
                pHead = pHead->next;
            }
            else{
                return pHead;
            }
        }
        return NULL;
    }
};
~~~

快慢双指针思路：设头结点A，环入口节点B，双指针第一次相遇节点C，则fast每次两步slow每次一步，第一相遇时有`AB+BC+CB+BC = 2(AB+BC)`，即`CB=AB`。则此时fast指向头结点A，slow不变，同时每次一步，相遇时即为环入口节点B。

~~~c++
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* fast = pHead;
        ListNode* slow = pHead;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow){
                break;
            }
        }
        if(fast == NULL || fast->next == NULL){
            return NULL;
        }
        fast = pHead;
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }
};
~~~



#### [24. 反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

迭代思路：断开节点2时，需要知道节点1，便于2->1；还要知道节点3，防止断开。

~~~c++
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(!pHead || !pHead->next){
            return pHead;
        }
        ListNode* cur = pHead;
        ListNode* pre = NULL;
        while(cur){
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
~~~

递归思路：递归基是找到最后一个节点。每拿到一个节点，都递归地往后找，并把找到的返回值作为tail，并返回tail（即最后一个节点）。head->next->next = head，head->next = nullptr

~~~c++
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(!pHead || !pHead->next){
            return pHead;
        }
        ListNode* tail = ReverseList(pHead->next);
        pHead->next->next = pHead;
        pHead->next = NULL;
        return tail;
    }
};
~~~



#### [25. 合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

递归思路：递归基是遇到空节点。每次进入只处理两个节点，比大小。

~~~c++
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(!pHead1){
            return pHead2;
        }
        if(!pHead2){
            return pHead1;
        }
        if(pHead1->val < pHead2->val){
            pHead1->next = Merge(pHead1->next, pHead2);
            return pHead1;
        }
        else{
            pHead2->next = Merge(pHead1, pHead2->next);
            return pHead2;
        }
    }
};
~~~

迭代思路：在不确定谁作为头结点的情况下，要预留哨兵节点。当一条链结束后，直接把另一条链接上去。

~~~c++
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode* preHead = new ListNode(-1);
        ListNode* node = preHead;
        while(pHead1 && pHead2){
            if(pHead1->val < pHead2->val){
                node->next = pHead1;
                pHead1 = pHead1->next;
            }
            else{
                node->next = pHead2;
                pHead2 = pHead2->next;
            }
            node = node->next;
        }
        if(pHead2 == NULL){
            node->next = pHead1;
        }
        else{
            node->next = pHead2;
        }
        return preHead->next;
    }
};
~~~

#### [二叉搜索树与双向链表](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。

思路：二叉搜索树的中序遍历就是排序的。而中序遍历的递归好写。

借助一个指针指向每次遍历到的节点，下一次中序遍历到的节点的前驱便是此指针指向的节点，而此节点的后序是此时遍历到的节点。

~~~c++
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree) {
        //递归的中序遍历。
        //借助一个指针指向每次遍历到的节点，下一次中序遍历到的节点的前驱便是此指针指向的节点，而此节点的后序是此时遍历到的节点。
        inOrderConvert(pRootOfTree);
        while (pRootOfTree != nullptr && pRootOfTree->left != nullptr)
            pRootOfTree = pRootOfTree->left;
        return pRootOfTree;
    }
    void inOrderConvert(TreeNode* root){
        if(!root) return;
        inOrderConvert(root->left);
        //设置前驱
        root->left = lastNodeList;
        if(lastNodeList){
            //设置前驱节点的后序
            lastNodeList->right = root;
        }
        //指针指向当前节点
        lastNodeList = root;
        inOrderConvert(root->right);
    }
private:
    TreeNode* lastNodeList = nullptr;
};
~~~



#### [35. 复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：以前还一直纠结“拼接+拆分”的方法。现在只想哈希。两次遍历，

~~~c++
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead) {
        if(pHead == NULL) return NULL;
        RandomListNode* cur = pHead;
        unordered_map<RandomListNode*, RandomListNode*> map;
        while(cur){//第一次遍历，创建新节点
            map[cur] = new RandomListNode(cur->label);
            cur = cur->next;
        }
        cur = pHead;
        while(cur){//第二次遍历，构建新节点的映射关系
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }
        return map[pHead];
    }
};
~~~



#### [52. 两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f1cb999-cb9a-4f6c-a0af-d90377295ab8.png" width="500"/> </div><br>

~~~c++
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* l1 = pHead1;
        ListNode* l2 = pHead2;
        while(l1 != l2){
            l1 = (l1 == NULL) ? pHead2 : l1->next;
            l2 = (l2 == NULL) ? pHead1 : l2->next;
        }
        return l1;
         
    }
};
~~~





## 树

#### [二叉树的遍历C++代码实现](https://blog.csdn.net/wangjian530/article/details/84139478)

#### [7. 重建二叉树【前序+中序】](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

思路：树都要想到递归。

LeetCode的代码：每次都要调用find在中序遍历中找到前序遍历首元素对应的下标。

~~~cpp
class Solution {
    map<int, int> indexOfInorders;
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.size() == 0 || vin.size() != pre.size()){
            return NULL;
        }
        return construct(pre.begin(),pre.end(),vin.begin(),vin.end());
    }
    //参数是前序遍历结果，待重构的范围中，前序的左右和中序的左
    TreeNode* construct(vector<int>::iterator preBegin, vector<int>::iterator preEnd,vector<int>::iterator inBegin,vector<int>::iterator inEnd){
        if (inEnd==inBegin) return nullptr;
        TreeNode* cur = new TreeNode(*preBegin);//前序遍历的第一个值是root
        auto root = find(inBegin, inEnd ,*preBegin);
        cur->left = construct(preBegin+1, preBegin+1+(root-inBegin), inBegin, root);//root-inBegin表示中序遍历中左子树的长度
        cur->right = construct(preBegin+1+(root-inBegin), preEnd, root+1, inEnd);
        return cur;
    }
};
~~~

#### [23. 二叉搜索树的后序遍历序列](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述: 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜索树）

思路：BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。

~~~c++
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        if(!sequence.size()) return false;
        return judge(sequence, 0, sequence.size()-1);
    }
    bool judge(vector<int>&s, int l, int h){//[]
        if(l >= h) return true;
        //找到左子树和右子树的分界点p。
        //比最后一个节点小的是左子树
        int p = l;
        //前一段符合
        while(p < h && s[p] < s[h]){
             p++;
        }
        //p是第一个大于根节点的，应该是右子树的第一个
        //看后一段是否符合
        for(int q = p; q < h; q++){
            if(s[q] < s[h]) return false;
        }
        return judge(s, l, p-1) && judge(s, p, h-1);
    }
};
~~~



#### [8. 二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

思路：输入是一个节点，要求找这个节点中序遍历的下一个节点。中序遍历是“左-中-右”，那么第一个节点是最左的节点。

1. 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7008dc2b-6f13-4174-a516-28b2d75b0152.gif" width="300px"/> </div><br>

2. 否则，向上找第一个左链接指向的树包含该节点的祖先节点。即一直往上走，直到当前节点是它的父节点的左节点，那么该父节点是下一个节点。

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/094e3ac8-e080-4e94-9f0a-64c25abc695e.gif" width="300px"/> </div><br>

~~~cpp
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
        if(pNode->right != nullptr){//有右子树
            TreeLinkNode* node = pNode->right;
            while(node->left != nullptr){//找右子树的最左节点
                node = node->left;
            }
            return node;
        }
        else{//没有右子树
            TreeLinkNode* node = pNode;
            while(node->next != nullptr){//往上找
                TreeLinkNode* parent = node->next;
                if(parent->left == node){
                    return parent;
                }
                node = node->next;
            }
        }
        return nullptr;
    }
};
~~~



#### [26. 树的子结构](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

描述：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

思路：树要想递归。肯定有个函数判断A作为根节点，A中是否有B，输入两个节点，判断B是否为空，判断AB的值是否相等，然后递归判断他们的左右子树。然后A中的每个节点都可能作为B开始的节点。

~~~cpp
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if(pRoot1 == nullptr || pRoot2 == nullptr) return false;
        //递归地比对A的每个节点作为B的根节点
        return isSubtreeWithRoot(pRoot1, pRoot2) || HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2);
    }
    //输入作为根节点，A中有B则返回true
    bool isSubtreeWithRoot(TreeNode* pRoot1, TreeNode* pRoot2){
        if(pRoot2 == nullptr) return true;//为什么要先判断B是否为空？因为当AB同时为空时，B就是A的子结构
        if(pRoot1 == nullptr) return false;
        if(pRoot1->val != pRoot2->val) return false;
        return isSubtreeWithRoot(pRoot1->left, pRoot2->left) && isSubtreeWithRoot(pRoot1->right, pRoot2->right);
    }
};
~~~



#### [27. 二叉树的镜像](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

描述：操作给定的二叉树，将其变换为源二叉树的镜像。

思路：翻转二叉树。就是先序遍历。

~~~cpp
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if(pRoot == nullptr){
            return;
        }
        swap(pRoot);
        Mirror(pRoot->left);
        Mirror(pRoot->right);
    }
    void swap(TreeNode *pRoot){
        TreeNode* tmp = pRoot->left;
        pRoot->left = pRoot->right;
        pRoot->right = tmp;
    }
};
~~~



#### [28. 对称二叉树](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

~~~cpp
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot == nullptr){
            return true;
        }
        return get_res(pRoot->left, pRoot->right);
    }
    bool get_res(TreeNode* l, TreeNode* r){
        //递归基，同时为空
        if(l == nullptr && r == nullptr){
            return true;
        }
        //只有一边空
        if(l == nullptr || r == nullptr){
            return false;
        }
        //都不空，但不相等
        if(l->val != r->val){
            return false;
        }
        //继续递归
        return get_res(l->left, r->right) && get_res(l->right, r->left);
    }
};
~~~



#### [32.1 从上往下打印二叉树](32.1%20从上往下打印二叉树.md)

#### [32.2 把二叉树打印成多行](32.2%20把二叉树打印成多行.md)

#### [32. 把二叉树打印成多行](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&&tqId=11213&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

思路：层次遍历要注意几个关键点，要用队列，通过记录队列的大小来控制每层的输出

~~~c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) {
            //层次遍历
            if(!pRoot) return {};
            queue<TreeNode*> q;
            q.push(pRoot);
            vector<vector<int> > res;
            while(!q.empty()){
                vector<int> level;
                int size = q.size();
                while(size--){
                    TreeNode* node = q.front();
                    level.push_back(node->val);
                    q.pop();
                    if(node->left) q.push(node->left);
                    if(node->right) q.push(node->right);
                }
                res.push_back(level);
            }
            return res;
        }
    
};
~~~



#### [32.3 按之字形顺序打印二叉树](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&&tqId=11212&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

思路：层次遍历，但是每一层要换方向。用队列，然后根据队列的大小控制每一层。

~~~c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        //层次遍历，但是每一层要换方向。
        //用队列，然后根据队列的大小控制每一层
        if(!pRoot) return{};
        deque<TreeNode*> dq;//左是back，右是front；保证装的都是按顺序的
        dq.push_back(pRoot);
        vector<vector<int> > res;
        bool l2r = 1;
        while(!dq.empty()){
            vector<int> tmp;
            int size = dq.size();
            while(size--){
                if(l2r){
                    //从左到右时，先装左再装右，从front装
                    TreeNode* node = dq.back();
                    dq.pop_back();
                    tmp.push_back(node->val);
                    if(node->left) dq.push_front(node->left);
                    if(node->right) dq.push_front(node->right);
                }
                else{
                    //从右到左时，先装右再装左，从back装
                    TreeNode* node = dq.front();
                    dq.pop_front();
                    tmp.push_back(node->val);
                    if(node->right) dq.push_back(node->right);
                    if(node->left) dq.push_back(node->left);
                }
            }
            l2r = !l2r;
            res.push_back(tmp);
        }
        return res;
        
    }
    
};
~~~



#### [33. 二叉搜索树的后序遍历序列](33.%20二叉搜索树的后序遍历序列.md)

#### [34. 二叉树中和为某一值的路径](34.%20二叉树中和为某一值的路径.md)

~~~cpp
class Solution {
public:
    vector<vector<int>> paths;
    vector<int> path;
    void backtracking(TreeNode* node,int expectNumber){
        if(!node){//在入口处处理空指针，所以可以接受空指针参数
            return;
        }
        path.emplace_back(node->val);
        expectNumber -= node->val;
        if(expectNumber == 0 && !node->left && !node->right){//已经到叶子节点且路径和为K
            paths.emplace_back(path);
        }
        else{//要么非叶子，要么值不为K
            backtracking(node->left, expectNumber);
            backtracking(node->right, expectNumber);
        }
        
        //有没有下面这句都能过，为什么呢？
        //因为expectNumber作为值传参，每次返回到上一层时有一个 当时的expectNumber备份，并不把这个传回去。
        //除非expectNumber写成引用传参int& expectNumber,那么就要恢复原状。
        //但是在这里好像用引用传参的内存占用更大。。
        //expectNumber += node->val;
        path.pop_back();
    }
    vector<vector<int>> FindPath(TreeNode* root,int expectNumber) {
        backtracking(root, expectNumber);
        return paths;
    }
};
~~~



#### [36. 二叉搜索树与双向链表](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

描述：输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

思路：路径定义为从根节点开始到叶节点结束，且要记录所有路径。递归+全局变量。

递归好像不行，因为要记录每个节点，要用回溯。

~~~cpp
class Solution {
public:
    vector<vector<int>> paths;
    vector<int> path;
    void backtracking(TreeNode* node,int expectNumber){
        if(!node){//在入口处处理空指针，所以可以接受空指针参数
            return;
        }
        path.emplace_back(node->val);
        expectNumber -= node->val;
        if(expectNumber == 0 && !node->left && !node->right){//已经到叶子节点且路径和为K
            paths.emplace_back(path);
        }
        else{//要么非叶子，要么值不为K
            backtracking(node->left, expectNumber);
            backtracking(node->right, expectNumber);
        }
        
        //有没有下面这句都能过，为什么呢？
        //因为expectNumber作为值传参，每次返回到上一层时有一个 当时的expectNumber备份，并不把这个传回去。
        //除非expectNumber写成引用传参int& expectNumber,那么就要恢复原状。
        //但是在这里好像用引用传参的内存占用更大。。
        //expectNumber += node->val;
        path.pop_back();
    }
    vector<vector<int>> FindPath(TreeNode* root,int expectNumber) {
        backtracking(root, expectNumber);
        return paths;
    }
};
~~~



#### [37. 序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：用char*类型的好难写。

~~~cpp
class Solution {
public:
    char* Serialize(TreeNode *root) {    
        if (!root) {
            return "#";
        }
        string res = to_string(root->val);
        res.push_back(',');
        char* left = Serialize(root->left);
        char* right = Serialize(root->right);
        char* ret = new char[strlen(left)+strlen(right)+res.size()];
        // 如果是string类型，直接用operator += ,这里char* 需要用函数
        strcpy(ret,res.c_str());
        strcat(ret,left);
        strcat(ret,right);
        return ret;
    }
    
    // 参数使用引用&， 以实现全局变量的目的
    TreeNode* deseri(char *&s) {
        if (*s == '#') {
            ++s;
            return nullptr;
        }

        // 构造根节点值
        int num = 0;
        while (*s != ',') {
            num = num * 10 + (*s - '0');
            ++s;
        }
        ++s; 
        // 递归构造树
        TreeNode *root = new TreeNode(num);
        root->left = deseri(s);
        root->right = deseri(s);

        return root;
    }

    TreeNode* Deserialize(char *str) {
        return deseri(str);
    }
};
~~~



#### [54. 二叉查找树的第 K 个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：利用二叉查找树中序遍历有序的特点。注意初始化res为空指针。

~~~cpp
class Solution {
private:
    TreeNode* res = nullptr;
    int cnt = 0;
public:
    void inorder(TreeNode* root, int k) {
        if(!root || cnt >= k){
            return;
        }
        inorder(root->left, k);
        cnt++;
        if(cnt == k){
            res = root;
        }
        inorder(root->right, k);
    }
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        inorder(pRoot, k);
        return res;
    }
};
~~~



#### [55.1 二叉树的深度](55.1%20二叉树的深度.md)

~~~cpp
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
        return pRoot == nullptr ? 0 : 1 + max(TreeDepth(pRoot->left), TreeDepth(pRoot->right));
    }
};
~~~



#### [55.2 平衡二叉树](55.2%20平衡二叉树.md)

~~~cpp
class Solution {
private:
    bool isBalence = true;
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
        height(pRoot);
        return isBalence;
    }
    int height(TreeNode* root){
        //做一下剪枝：当已经发现不平衡时，后面的高度就不必计算了
        if(!root || !isBalence){
            return 0;
        }
        int left = height(root->left);
        int right = height(root->right);
        if(abs(left - right) > 1){
            isBalence = false;
        }
        return 1 + max(left, right);
    }
};
~~~



#### [68.1 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

思路：在二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val \>= p.val && root.val \<= q.val。

~~~cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root){
            return root;
        }
        if(root->val > p->val && root->val > q->val){
            return lowestCommonAncestor(root->left, p, q);
        }
        if(root->val < p->val && root->val < q->val){
            return lowestCommonAncestor(root->right, p, q);
        }
        return root;//包括了root的值等于p或q的情况
    }
};
~~~



#### [68.2 普通二叉树的最近公共祖先](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。

~~~cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root == q){
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else if (right != null) {
            return right;
        }
        return null;
    }
};
~~~



## 贪心思想

- [14. 剪绳子](14.%20剪绳子.md)
- [63. 股票的最大利润](63.%20股票的最大利润.md)

## 二分查找

#### [11. 旋转数组的最小数字](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

思路：关键是二分法的mid和哪边比。和左边比是错误的，当mid和lo都在同一段子序列时，不能得出最小值在[mid， hi]的结论。

代入示例：3,1,3,3 和 1,3,3

~~~cpp
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        int lo = 0, hi = rotateArray.size() - 1;//hi可取得
        while(lo < hi){//结束时lo == hi
            int mi = lo + (hi - lo)/2;
            if(rotateArray[mi] < rotateArray[hi]){
                hi = mi;
            }
            else if(rotateArray[mi] > rotateArray[hi]){
                lo = mi + 1;
            }
            else{//rotateArray[mi] == rotateArray[hi]，即最小值可能在左边也可能在右边，但唯一确定的是一定在hi的左边。所以让hi向左靠近。
                hi--;
            }
        }
        return rotateArray[lo];
    }
};
~~~



[53. 数字在排序数组中出现的次数](53.%20数字在排序数组中出现的次数.md)

## 分治

- [16. 数值的整数次方](16.%20数值的整数次方.md)

## 搜索

#### [12. 矩阵中的路径](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

描述：判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 

思路：回溯，且要标记是否访问，定义方向数组。

~~~cpp
class Solution {
private:
    //定义上下左右。因为可以从任意一个格子开始，不一定是往右下角。
    int next[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
    bool pathExist = false;
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        vector<vector<char>> m = buildMatrix(matrix, rows, cols);
        vector<vector<bool>> visited(rows, vector<bool>(cols, false));
        for(int i = 0; i < rows; i++){
            for(int j = 0; j < cols; j++){
                backtracking(m, visited, i, j, str, 0);
            }
        }
        return pathExist;
    }
    void backtracking(vector<vector<char>>& matrix, vector<vector<bool>>& visited, int row, int col, char* str, int length){
        //剪枝：如果已经找到那么直接返回
        if(pathExist){
            return;
        }
        //返回情况包括：越界， 已经访问过，当前字母不同
        if(row < 0 || row >= matrix.size() || col < 0 || col >= matrix[0].size() || visited[row][col] || str[length] != matrix[row][col]){
            return;
        }
        //如果路径长度满足
        if(length + 1 == strlen(str)){
            pathExist = true;
            return;
        }
        visited[row][col] = true;
        for(auto n : next){
            backtracking(matrix,visited, row + n[0], col + n[1], str, length + 1);
        }
        visited[row][col] = false;
    }
    vector<vector<char>> buildMatrix(char* matrix, int rows, int cols){
        vector<vector<char>> m(rows, vector<char>(cols));
        int idx = 0;
        for(int i = 0; i < rows; i++){
            for(int j = 0; j < cols; j++){
                m[i][j] = matrix[idx++];
            }
        }
        return m;
    }
};
~~~



#### [机器人的运动范围](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&&tqId=11219&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：地上有一个rows行和cols列的方格。坐标从 [0,0] 到 [rows-1,cols-1]。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于threshold的格子。 例如，当threshold为18时，机器人能够进入方格[35,37]，因为3+5+3+7 = 18。但是，它不能进入方格[35,38]，因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

思路：需要标记的BFS。

~~~c++
class Solution {
public:
    int movingCount(int threshold, int rows, int cols) {
        //BFS,往下和右
        vector<vector<int>> visited(rows, vector<int>(cols,0));
        bfs(visited, threshold, rows, cols, 0, 0);
        return count;
    }
    
    int get_digit_sum(int n){
        int sum = 0;
        while(n){
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
    void bfs(vector<vector<int>>&visited, int threshold, int rows, int cols, int i, int j){
        int sum = get_digit_sum(i) + get_digit_sum(j);
        if(i < 0 || i >= rows || j < 0 || j >= cols || sum > threshold || visited[i][j] == 1) return;
        count++;
        visited[i][j] = 1;
        bfs(visited, threshold, rows, cols, i+1, j);
        bfs(visited, threshold, rows, cols, i, j+1);
    }
private:
    int count = 0;
};
~~~



#### [字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&&tqId=11180&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

思路：字典序就是，每一位上都可能是str的任意一个没用过字符，但要按照字母顺序。

带记录的回溯法。

~~~c++
class Solution {
public:
    vector<string> Permutation(string str) {
        //回溯，但是有重复。重复需要剪枝
        vector<int> visited(str.size(), 0);
        string path = "";
        sort(str.begin(), str.end());
        backtrack(str, path, visited);
        return res;
    }
    void backtrack(string& str, string& path, vector<int>& visited){
        if(path.size() == str.size()){
            res.push_back(path);
            return;
        }
        //每个位置上都可以是任意一个，只要不重复使用
        for(int i = 0; i < str.size(); i++){
            if(!visited[i]){
                //剪枝，如果当前字母和前一个相同，且前一个字母没用过（没用过代表已经回溯到上一字母的上一个）
                if(i >= 1 && str[i] == str[i-1] && !visited[i-1]) continue;
                path.push_back(str[i]);
                visited[i] = 1;
                backtrack(str, path, visited);
                visited[i] = 0;
                path.pop_back();
            }
        }
        
    }
private:
    vector<string> res;
};
~~~



#### [65. 矩阵中的路径](https://www.nowcoder.com/practice/2a49359695a544b8939c77358d29b7e6?tpId=13&&tqId=11218&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

题目描述：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

思路：典型的dfs。先写好框架，双重for循环遍历每个格子为开始；然后dfs，因为不用记录路径，直接判断值相等作为条件即可。

不能重复访问有两种方法，一是用一个同大小的visited，二是修改原矩阵的值为不可能存在的值。

~~~c++
class Solution {
public:
    bool hasPath(vector<vector<char> >& matrix, string word) {
        // write code here
        for(int i = 0; i < matrix.size(); i++){
            for(int j = 0; j < matrix[0].size(); j++){
                if(dfs(matrix, word, i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }
    bool dfs(vector<vector<char> >& matrix, string& word, int i, int j, int index){
        //处理越界、值不相等
        if(i >= matrix.size() || i < 0 || j >= matrix[0].size() || j < 0 || word[index] != matrix[i][j]){
            return false;
        }
        //值相等才能走到这一步
        if(index == word.size()-1){
            return true;
        }
        //不能重复访问有两种方法
        //一是用一个同大小的visited
        //二是修改原矩阵的值为不可能存在的值。
        char tmp = matrix[i][j];
        matrix[i][j] = '.';
        bool res = dfs(matrix, word, i-1, j, index+1) ||
            dfs(matrix, word, i+1, j, index+1) ||
            dfs(matrix, word, i, j-1, index+1) ||
            dfs(matrix, word, i, j+1, index+1);
        matrix[i][j] = tmp;
        return res;
    }
};
~~~



## 排序

[21. 调整数组顺序使奇数位于偶数前面](21.%20调整数组顺序使奇数位于偶数前面.md)

[45. 把数组排成最小的数](45.%20把数组排成最小的数.md)

#### [51. 数组中的逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

思路：插入排序需要交换的次数为逆序数量，但只能交换相邻的元素，每次只能将逆序数量减少 1。归并排序更快，而且能递归地计算逆序对。

~~~cpp
class Solution {
public:
    int InversePairs(vector<int> data) {
        vector<int> tmp(data.size());
        return mergeSort(data, tmp, 0, data.size()-1);
    }
    int mergeSort(vector<int>& data, vector<int>& tmp, int l, int r){
        if(l >= r) return 0;
        int mid = l + (r - l)/2;
        int inv_count = mergeSort(data, tmp, l, mid) + mergeSort(data, tmp, mid+1, r);//分治处理
        //开始合并
        int i = mid, j = r, pos = r;//i，j指向有序数组的末尾
        while(i >= l && j >= mid+1){
            if(data[i] <= data[j]){
                tmp[pos--] = data[j--];
            }
            else{
                tmp[pos--] = data[i--];
                inv_count += (j - mid);//i大于从mid+1到j所有的数，所以有j-mid个逆序对。
            }
        }//退出时，i==l || j==mid+1。也就是剩下的都是小的,直接接在temp的前面
        for(; i >= l; --i){
            tmp[pos--] = data[i];
        }
        for(; j >= mid+1; --j){
            tmp[pos--] = data[j];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, data.begin() + l);//每次排序后要将排序结果保存到原数组。
        return inv_count;
    }
};
~~~

一样的代码，在leetcode能过，牛客不能过。

## 动态规划

#### [10.1 斐波那契数列](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：`f(n)=f(n-1)+f(n-2)`

~~~c++
class Solution {
public:
    int Fibonacci(int n) {
        if(n == 0 || n == 1) return n;
        int cur;
        int pre1 = 1, pre2 = 0; 
        for(int i = 2; i <= n; i++){
            cur = pre1 + pre2;
            pre2 = pre1;
            pre1 = cur;
        }
        return cur;
    }
};
~~~



#### [10.2 矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

思路：要覆盖 2\*n 的大矩形，可以先覆盖 2\*1 的矩形，再覆盖 2\*(n-1) 的矩形；或者先覆盖 2\*2 的矩形，再覆盖 2\*(n-2) 的矩形。而覆盖 2\*(n-1) 和 2\*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="370px"> </div><br>

~~~c++
class Solution {
public:
    int rectCover(int number) {
        if(number < 3) return number;
        int cur;
        int pre1 = 2, pre2 = 1;
        for(int i = 3; i <= number; i++){
            cur = pre1 + pre2;
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
~~~



#### [10.3 跳台阶](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

思路：`f(1) = 1, f(2) = 2, f(3) = 3,f(n) = f(n-1)+f(n-2)`

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="350px"> </div><br>

~~~c++
class Solution {
public:
    int jumpFloor(int number) {
        if(number < 3) return number;
        int cur;
        int pre1 = 2, pre2 = 1;
        for(int i = 3; i <= number; i++){
            cur = pre1 + pre2;
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
~~~



#### [10.4 变态跳台阶](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

思路：`f(n) = f(n-1)+f(n-2)+……+f(1)`

~~~c++
class Solution {
public:
    int jumpFloorII(int number) {
        if(number < 3) return number;
        vector<int> dp(number+1, 1);//每一级都可以一步跳到
        for(int i = 1; i <= number; i++){
            for(int j = 1; j < i; j++){
                dp[i] += dp[j];
            }
        }
        return dp[number];
    }
};
~~~

数学推导：等比数列

~~~c++
class Solution {
public:
    int jumpFloorII(int number) {
        return (int)pow(2, number-1);
    }
};
~~~



#### [42. 连续子数组的最大和](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).

思路：时间复杂度为 O(n)就是一次扫描。求所有子数组的和的最大值有点像贪心。前面是负数那肯定是不要的了。dp的长度为n。

~~~c++
            int tmpSum = dp[i-1] + array[i-1];
            dp[i] = tmpSum > 0 ? tmpSum : 0;
如果这样写的话，全负输入就不行了。
~~~

下面的思路是，如果累计到上个元素的和大于0，那么继续加，否则抛弃前面的。但是写的冗余了。

~~~c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        vector<int> dp(array.size()+1,0);
        int maxSum = INT_MIN;
        for(int i = 1; i <= array.size(); i++){
            int tmpSum = dp[i-1] + array[i-1];
            dp[i] = tmpSum > array[i-1] ? tmpSum : array[i-1];
            maxSum = max(maxSum, dp[i]);
        }
        return maxSum;
    }
};
~~~

优化思路：每次dp都只用到前一个。可以优化空间

~~~c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if (array == NULL || array.size() == 0) return 0;
        int maxSum = INT_MIN;
        int sum = 0;
        for(int val : array){
            sum = sum <= 0 ?val : sum + val;
            maxSum = max(maxSum, sum);
        }
        return maxSum;
    }
};
~~~

##### follow up:要求输出区间

需要维护前缀和sum和最大子数组和maxSum；

当`sum >= 0` 时，说明前面一段有效，sum需要继续累加。但end是否后移还需要再判断。

否则前面舍弃，从当前开始。

如果前面一段有效，而且比以往得最大和都大，那么需要更新maxSum以及end。

如果无需更新maxSum，也无需更新end。

~~~c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if (array == NULL || array.size() == 0) return 0;
        int maxSum = INT_MIN;
        int sum = 0;
        int start = 0, end = 0;
        for(int i = 0; i < array.size(); i++){
            if(sum >= 0){
                sum += array[i];
            }
            else{
                start = i;
                end = i+1;
                sum = array[i];
            }
            if(maxSum < sum){
                end = i+1;
                max = sum;
            }
        }
        return maxSum, start, end-1;
    }
};
~~~



#### [47. 礼物的最大价值](https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab)

这题的链接有点问题，

思路：应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。

动态规划的思路是，每一行中每个格都来自上或左的较大者加当前值。

~~~c++
class Bonus {
public:
    int getMost(vector<vector<int> > board) {
        if( board.size() == 0 || board[0].size() == 0){
            return 0;
        }
        int n = board[0].size();
        vector<int> dp(board.size());
        for(auto row : board){
            dp[0] += row[0];
            for(int i = 1; i < row.size(); i++){
                dp[i] = max(dp[i], dp[i-1]) + row[i];
            }
        }
        return dp[n-1];
    }
};
~~~

#### [48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

题目描述：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

思路：记录每个字母出现的最后一个位置？窗口的增加要同时考虑没出现过和出现过但不在当前窗口内两种情况。

~~~c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        if(n <= 1 ) return n;
        unordered_map<char, int> map;
        int maxL = 0, curL = 0;
        for(int i = 0; i < n; i++){
            if(map.find(s[i]) == map.end() || i - map[s[i]] > curL){ 
                curL++;
                maxL = max(curL, maxL);
            }
            else{
                curL = i - map[s[i]];
            }
            map[s[i]] = i;
        }
        return maxL;
    }
};
~~~



#### [49. 丑数](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

思路：想到用dp的原因，每个丑数都是由前一个丑数乘2/3/5得到的。`dp[n] = min(dp[i2] * 2, dp[i3] * 3, dp[i5]*5 )`,i2i3i5每次使用（或结果相等但未使用）才往前走一步。

~~~cpp
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        if(index <= 6) return index;
        int dp[index];
        dp[0] = 1;
        int i2 = 0, i3 = 0, i5 = 0;
        for(int i = 1; i < index; i++){
            int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5]*5;
            dp[i] = min(next2, min(next3, next5));
            if(dp[i] == next2) i2++;
            if(dp[i] == next3) i3++;
            if(dp[i] == next5) i5++;
        }
        return dp[index-1];
    }
};
~~~



#### [60. n 个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/submissions/)

题目描述：扔 *n* 个骰子，向上面的数字之和为 *S*。给定 *n*，请列出所有可能的 *S* 值及其相应的概率。

思路：这跟dp有什么关系？dp\[i]\[j] 表示前 i 个骰子产生点数 j 的次数。但转移方程中，`dp[i][j] += dp[i - 1][j - k];`这一次的结果只与上一次的有关，所以可以优化dp的空间为2*(最大点数和+1)。

即，每一次得到的sum的分布都由上次的和加上{1,2,3,4,5,6}得到

~~~cpp
class Solution {
public:
    vector<double> dicesProbability(int n) {
        int face = 6;
        int maxSum = face * n;
        vector<vector<int>> dp(2, vector<int>(maxSum + 1, 0));
        for(int i = 1; i <= face; i++){
            dp[0][i] = 1;//初始化第一次
        }
        int flag = 1;
        for(int i = 2; i <= n; i++, flag = 1 - flag){//每一次投骰子
            for(int j = 0; j <= maxSum; j++){// 因为要累加，所以要先清零
                dp[flag][j] = 0;
            }
            for(int j = i; j <= maxSum ; j++){//随着每次掷骰子，都会有一个sum不可能再取到，这个sum的范围为[0, i-1]
                for(int k = 1; k <= face && k < j; k++){
                    dp[flag][j] += dp[1 - flag][j - k];
                }
            }
        }
        double totalNum = pow(face, n);
        vector<double> res;
        for(int i = n; i <= maxSum; i++){
            res.push_back(dp[1 - flag][i] / totalNum);//因为循环结束时执行了flag = 1 - flag
        }
        return res;
    }
};
~~~

还可以使用离散卷积的概念

~~~cpp
class Solution {
public:
    vector<double> dicesProbability(int n) {
        vector<double> res(6,1.0/6);
        for(int i=2; i<=n; i++){
            vector<double> prob_n(5*i+1,0);//卷积结果长度是NC=NA+NB-1，但在这里每次卷积核长度都是6，所以可以约成5*i+1
            //这个循环实现移位
            for(int j=0; j < res.size(); j++){
                //下面这个循环就是模拟卷积中的相乘求和
                for(int k=0; k<6; k++){                    
                    prob_n[j+k] += res[j] * 1.0/6;
                }
            }
            res = prob_n;
        }
        return res;
    }
};
~~~



#### [66. 构建乘积数组](https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

题目描述：`给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）`

对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。

~~~cpp
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        int n = A.size();
        vector<int> B(n);
        int product = 1;
        for(int i = 0; i < n; i++){//左向右乘
            B[i] = product;
            product *= A[i];
        }
        product = 1;
        for(int i = n-1; i >=0; i--){//右向左乘
            B[i] *= product;
            product *= A[i];
        }
        return B;
    }
};
~~~

#### [67. 剪绳子](https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？

思路：

​	数学法：最优解是2.7，f(2)<f(3),所以都分成长度为3的。根据余数处理，余1时比较特殊，再拿一个3出来，拆成2*2；

​	动态规划：dp[i]表示长度为i的绳子的最大乘积；[分割整数的最大乘积](#分割整数的最大乘积)

~~~c++
class Solution {
public:
    int cutRope(int number) {
        if(number == 2) return 1;
        if(number == 3) return 2;
        vector<int> dp(number+1);
        //初始化
        dp[1] = 1;
        for(int i = 2; i <= number; i++){
            for(int j = 1; j < i; j++){
                dp[i] = max(max((j) * dp[i-j], dp[i]), j*(i-j));
            }
        }
        return dp[number];
    }
};
~~~



## 数学

#### [11. 二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

题目描述：输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

思路：暴力法会对0也进行判断。而用`val = val & (val-1) `可以消去一个最低位的1。

~~~c++
class Solution {
public:
     int  NumberOf1(int n) {
         //技巧：val = val & (val-1) 可以消去一个最低位的1
         int res = 0;
         while(n != 0){
             ++res;
             n = n & (n-1);
         }
         return res;
     }
};
~~~

#### [12. 数值的整数次方](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。

思路：stl的pow用的是快速幂方法。

~~~c++
class Solution {
public:
    double Power(double base, int exponent) {
        //快速幂方法：将幂次表示为二进制，二进制中的1则乘上对应的x^2^n。
        if(exponent < 0){
            base = 1 / base;
            exponent = -exponent;
        }
        double x = base;//x^0, x^1, x^2,x^……
        double res = 1.0;
        while(exponent){
            if(exponent & 1){
                res *= x;
            }
            x *= x;
            exponent >>= 1;
        }
        return res;
    }
};
~~~



#### [39. 数组中出现次数超过一半的数字](39.%20数组中出现次数超过一半的数字.md)

#### [62. 圆圈中最后剩下的数](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github&tab=answerKey)

约瑟夫环问题，用递归解决。

~~~cpp
class Solution {
public:
    int LastRemaining_Solution(int n, int m) {
        if (n == 0)     /* 特殊输入的处理 */
        return -1;
        if (n == 1)     /* 递归返回条件 */
        return 0;
        return (LastRemaining_Solution(n - 1, m) + m) % n;
    }
};
~~~



#### [43. 从 1 到 n 整数中 1 出现的次数](43.%20从%201%20到%20n%20整数中%201%20出现的次数.md)

## 位运算

- [15. 二进制中 1 的个数](15.%20二进制中%201%20的个数.md)
- [56. 数组中只出现一次的数字](56.%20数组中只出现一次的数字.md)

## 其它

[17. 打印从 1 到最大的 n 位数](17.%20打印从%201%20到最大的%20n%20位数.md)

#### [19. 正则表达式匹配](https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，`字符串"aaa"与模式"a.a"和"ab*ac*a"匹配`，但是与"aa.a"和"ab*a"均不匹配

思路：动态规划，比较烦。`n*m的矩阵，要分三种情况，字母，*，.。`

递归掉用，分情况。

~~~c++
class Solution {
public:
    bool match(string str, string pattern) {
        //递归，只看s的一个，看p的一个或两个。当p的第二个为*时，就要考虑0次和多次
        if(pattern.empty()){
            return str.empty();//空串匹配空串
        }
        bool firstMatch = (!str.empty()&&(str[0] == pattern[0] || pattern[0] == '.'));
        if(pattern.size() >= 2 && pattern[1] == '*'){
            return(match(str,pattern.substr(2)) || (firstMatch && match(str.substr(1),pattern)));
        }
        else{
            //分0次和无数次
            //0次：p的这两个都不要，比较s和p.substr(2)
            //无数次：丢掉s的第一个，firstMatch && match(str.substr(1),pattern)
            return firstMatch && match(str.substr(1),pattern.substr(1));
        }
    }
};
~~~



[20. 表示数值的字符串](20.%20表示数值的字符串.md)

[44. 数字序列中的某一位数字](44.%20数字序列中的某一位数字.md)

[46. 把数字翻译成字符串](46.%20把数字翻译成字符串.md)

#### [扑克牌顺子](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&&tqId=11198&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述：现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。
有如下规则：

1. A为1，J为11，Q为12，K为13，A不能视为14
2. 大、小王为 0，0可以看作任意牌
3. 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。

思路：找到非0的最小值。排除重复值

~~~c++
class Solution {
public:
    bool IsContinuous( vector<int> numbers ) {
        sort(numbers.begin(),numbers.end());
        int i = 0, size = numbers.size();
        for(int j = 0; j < size; j++){
            if(numbers[j] == 0){
                ++i;
                continue;
            }
            if(j < size - 1 && numbers[j] == numbers[j+1]) return false;
        }
        return numbers.back() - numbers[i] < 5;
    }
};
~~~



[64. 求 1+2+3+...+n](64.%20求%201+2+3+...+n.md)

[65. 不用加减乘除做加法](65.%20不用加减乘除做加法.md)

[67. 把字符串转换成整数](67.%20把字符串转换成整数.md)

# 真题/模拟题

#### 24点

题目描述

计算24点是一种扑克牌益智游戏，随机抽出4张扑克牌，通过加(+)，减(-)，乘(*), 除(/)四种运算法则计算得到整数24，本问题中，扑克牌通过如下字符或者字符串表示，其中，小写joker表示小王，大写JOKER表示大王： 

​          3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER

本程序要求实现：输入4张牌，输出一个算式，算式的结果为24点。 

详细说明： 

1.运算只考虑加减乘除运算，没有阶乘等特殊运算符号，友情提醒，整数除法要当心； 

2.牌面`2~10对应的权值为2~10, J、Q、K、A权值分别为为11、12、13、1`； 

3.输入4张牌为字符串形式，以一个空格隔开，首尾无空格；如果输入的4张牌中包含大小王，则输出字符串“ERROR”，表示无法运算； 

4.输出的算式格式为4张牌通过+-*/四个运算符相连，中间无空格，4张牌出现顺序任意，只要结果正确； 

5.输出算式的运算顺序从左至右，不包含括号，如1+2+3*4的结果为24

6.如果存在多种算式都能计算得出24，只需输出一种即可，如果无法得出24，则输出“NONE”表示无解。

思路：

1. 输入是个问题，将输入识别成数字。若遇到大小王输出ERROR；

2. 动态规划吗？并不是一个求最值问题。

3. 暴力求解时的问题规模：4个数字，3个运算符。由于不允许带括号，而且数字先后顺序不固定，所以对于数字位来说肯定是排序问题，一共4*3*2*1 = 24种排列，

   另外对于运算符，每个位置都有4种取值可能，故是4^3 = 64种，所以整体的问题规模是 24*64 = 1536个计算组合。也就是给定4个数字，最极端的情况也就1536次四则运算，这个问题规模2s内完成。

以下代码无法AC

~~~cpp
#include <iostream> 
#include<string>
#include<string.h>
#include <algorithm>  
using namespace std;
int num[4];
int signal;
string operations = "+-*/";
bool dfs(int start,int sum)
{
    if (start==4&&sum == 24)
    {    
        signal = 1;
        for (int i = 0; i < 3; i++)
        {
            if(num[i] >= 2 && num[i] <= 10){
                cout << num[i];
            }
            else{
                switch(num[i]){
                    case 1: cout << 'A';
                    case 11: cout << 'J';
                    case 12: cout << 'Q';
                    case 13: cout << 'K';
                }
            }
            cout << operations[i];
            
        }
        if(num[4] >= 2 && num[4] <= 10){
            cout << num[4] << endl;
        }
        else{
            switch(num[4]){
                case 1: cout << 'A' << endl;
                case 11: cout << 'J' << endl;
                case 12: cout << 'Q' << endl;
                case 13: cout << 'K' << endl;
            }
        }
        return true;
    }
    for (int i = start; i < 4; i++)
    {
        if (!signal) {
            operations[start - 1] = '+';
            dfs(start + 1, sum + num[start]);
        }
        if (!signal) {
            operations[start - 1] = '-';
            dfs(start + 1, sum - num[start]);
        }
        if (!signal) {
            operations[start - 1] = '*';
            dfs(start + 1, sum * num[start]);
        }
        if (!signal) {
            operations[start - 1] = '/';
            dfs(start + 1, sum / num[start]);
        }
    }
    return signal;
}
int main()
{
    string str[4], strData = " A234567891JQK";//1是占位的
    while (cin>>str[0]>> str[1] >> str[2] >> str[3] )
    {   
        int error = 0;
        signal = 0;
        for (int i=0;i<4;i++)
        {
            if (str[i] == "10") num[i] = 10;
            else if(strData.npos == strData.find(str[i]))
            {
                error = 1;
                cout << "ERROR" << endl;
                break;
            }
            else  num[i] = strData.find_first_of(str[i]);
        }
        if (!error)
        {
            do
            {
                if (dfs(1, num[0])) break;
            } while (next_permutation(num, num + 4));
            if (!signal) cout << "NONE" << endl;
        }
    }
    return 0;
}
~~~

#### 从单向链表中删除指定值的节点

题目描述
![image-20210328203648502](https://gitee.com/Raymond-Z/typora/raw/master/image/20210328203649.png)

思路：

1. 能用链表来实现，也可以用unordered_map来实现.

自己写的unordered_map实现

~~~cpp
//第四十六题  从单向链表中删除指定值的节点
#include<iostream>
#include<unordered_map>
using namespace std;

int main() 
{
	int n, head_value;
    unordered_map<unsigned int, unsigned int> list;
	while (cin >> n >> head_value) 
	{
        list[head_value] = -1;
		for (int i = 0; i < n - 1; i++) 
		{
			int x, y;
			cin >> x >> y;
            list[x] = list[y];
            list[y] = x;
		}
		int denum;
		cin >> denum;
		if(denum == head_value){
            if(list[head_value] == head_value){//只有一个节点
                return 0;
            }
            else{
                head_value = list[head_value];
            }
            
        }
        
        int node = head_value;
        cout << node << ' ';
        while(list[node] != -1){
            if(list[node] == denum){
                node = list[node];
            }
            cout << list[node] << ' ';
            node = list[node];
        }
		cout << endl;
	}
	return 0;
}
 
~~~

#### [淘汰分数_ 美团2021](https://www.nowcoder.com/test/question/9c4a4e879b4f49939dfaebea8948f976?pid=28665343&tid=42874462)

![image-20210329204312501](https://gitee.com/Raymond-Z/typora/raw/master/image/20210329204313.png)

思路：排序后，从小到大遍历淘汰人数（一定有一个人淘汰，因为x>=1）。看淘汰人数和晋级人数在不在范围内。

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n, x, y;
    cin >> n >> x >> y;
    vector<int> A(n);
    for(int i = 0; i < n; ++i){
        cin >> A[i];
    }
    sort(A.begin(), A.end());
    int m = -1;
    for(int i = 1; i <= n; ++i){
         int j = n - i;//晋级人数
        if(i >= x && j <= y){
            m = A[i-1];
            break;
        }
    }
    cout << m;
    return 0;
}
~~~

#### [ 正则序列_ 美团2021](https://www.nowcoder.com/question/next?pid=28665343&qid=1371127&tid=42874462)

~~~cpp
#include <bits/stdc++.h>
using namespace std;
 
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;
    int arr[20020];
    scanf("%d",&n);
    for(int i = 0;i < n;i++)
    {
        scanf("%d",&arr[i]);
    }
    sort(arr,arr+n);

    int ans = 0;
    for(int i = 0; i < n; ++i)
    {
        ans += abs(i + 1 - arr[i]);
    }
    cout << ans << endl;
}
~~~

#### [公司食堂_美团笔试题](https://www.nowcoder.com/questionTerminal/601815bea5544f389bcd20fb5ebca6a8)

**用endl超时，用‘\n’可以通过**

![image-20210330143903342](https://gitee.com/Raymond-Z/typora/raw/master/image/20210330143904.png)

用两个指针，保存第一个单人桌和空桌的位置。

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T = 0;
    cin >> T;
    for (int k = 0;k < T;++k) {
        int N, M;
        cin >> N;
        string desk, que;
        cin >> desk;
        cin >> M;
        cin >> que;
        int f_zero = -1, f_one = -1;
        for (int i = 0; i < N; ++i) {
            if (f_zero != -1 && f_one != -1) break;
            if (f_zero == -1 && desk[i] == '0') f_zero = i;
            if (f_one == -1 && desk[i] == '1') f_one = i;
        }
        for (int i = 0; i < M; ++i) {
            if (que[i] == 'M') {//男的
                if (f_one < N) {//还有拼桌
                    //printf("%d\n", f_one + 1);
                    cout << f_one + 1 << endl;
                    desk[f_one] = '2';
                    while (f_one < N && desk[f_one] != '1') ++f_one;
                }
                else {//没有拼桌了
                    //printf("%d\n", f_zero + 1);
                    cout << f_zero + 1 << endl;
                    desk[f_zero] = '1';
                    if (f_zero < f_one) f_one = f_zero;//更新拼桌
                    while (f_zero < N && desk[f_zero] != '0') ++f_zero;//更新空桌
                }
            }
            else {//女的
                if (f_zero < N) {//还有空桌
                    //printf("%d\n", f_zero + 1);
                    cout << f_zero + 1 << endl;
                    desk[f_zero] = '1';
                    if (f_zero < f_one) f_one = f_zero;
                    while (f_zero < N && desk[f_zero] != '0') ++f_zero;
                }
                else {
                    //printf("%d\n", f_one + 1);
                    cout << f_one + 1 << endl;
                    desk[f_one] = '2';
                    while (f_one < N && desk[f_one] != '1') ++f_one;
                }
            }
        }
    }
    return 0;
}
~~~



# 算法 - 排序

[十大经典排序算法（动图演示C++实现）](https://blog.csdn.net/zhangsy_csdn/article/details/91483600)

## 算法概述

### 0.1 算法分类

十种常见排序算法可以分为两大类：

（选泡插，快归堆希统计基）

比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322225055.png)

### 0.2 算法复杂度

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322225115.png)

### 0.3 相关概念

稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。

不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。

时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。

空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

### 算法选择

影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：

1．待排序的记录数目n的大小；

2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；

3．关键字的结构及其分布情况；

4．对排序稳定性的要求。

设待排序元素的个数为n.

1. 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序。

   1. 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
   2. 堆排序 ：  如果内存空间允许且要求稳定性的，
   3. 归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。

2. 当n较大，内存空间允许，且要求稳定性 ——归并排序

3. 当n较小，可采用直接插入或直接选择排序。

   1. 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。
   2. 直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序

4. 一般不使用或不直接使用传统的冒泡排序。

5. 基数排序

   它是一种稳定的排序算法，但有一定的局限性：

   1. 关键字可分解。
   2. 记录的关键字位数较少，如果密集更好
   3. 如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。

## 1、冒泡排序（Bubble Sort）

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

### 1.1 算法描述

一趟：

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；

2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；

3. 针对所有的元素重复以上的步骤，除了最后一个；

一趟下来，最大的那个数就排在了最后面，那么下一趟对前n-1个数做同样的操作

重复步骤1~3，直到排序完成。

### 1.2 动图演示

黄色表示已排序部分，蓝色表示未排序部分，

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322225203.gif)

### 1.3 代码实现

~~~cpp
//冒泡法
/*
相邻元素比较：选择小的元素放在前面
非相邻元素比较，则是插入法的思想
*/
void BubbleSort(int a[], int len)
{
	int i, j, tmp;
	int exchange = 1;
	//外层比较，确定n-1趟
	for (i = 0; (i < len-1) && (exchange >0); i++)	{
		int tmp;
		exchange = 0;
		for (j =  len - 1 ; j >0 ; j--){      //从后往前冒泡				
			if (a[j ] < a[j-1]){			//相邻元素比较			
				tmp = a[j ];
				a[j] = a[j-1];
				a[j-1] = tmp;
				exchange = 1;
			} 
		}
	}
}
~~~



## 2、选择排序（Selection Sort）

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：

选择前面n-1个数中的最大值，和当前队尾数据交换，因为要交换最大值，所以要记录最大值位置的索引

首先在未排序序列中找到最大元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最大元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

### 2.1 算法描述

n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

初始状态：无序区为R[1..n]，有序区为空；

第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；

n-1趟结束，数组有序化了。

### 2.2 动图演示

黄色表示已排序部分，蓝色表示未排序部分，红色表示从未排序中选择的最小值

　　![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322225801.gif)

### 2.3 代码实现

~~~cpp
//选择排序法
/*
从该位置后面选择最小的元素放在该位置
*/ 
 
void SelectSort(int a[],int len)
{
	//外层循环跑n趟
 
	for (int i = 0; i < len; i++){ 
		//内层循环找出最小值进行交换
		int tmp;
		for (int j = i; j < len; j++){ 
			if (a[j] < a[i]){
				tmp = a[j];
				a[j] = a[i];
				a[i] = tmp;
			}
		}
	}
}
~~~

### 2.4 算法分析

表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

## 3、插入排序（Insertion Sort）

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 3.1 算法描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素key，在已经排序的元素序列中从后向前扫描；
3. 如果扫描到的元素（已排序）大于新元素key，将扫描到的元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 从接下来的n-1个开始
7. 重复步骤2~5。

### 3.2 动图演示

黄色表示已排序部分，蓝色表示未排序部分，红色表示当前正在处理的key

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322225942.gif)

### 3.3 代码实现

~~~cpp
// 插入排序法
 
/*
插入排序法：
拿着当前位置元素和前面的元素进行比较，只要当前元素比前面的元素大，则插入到该元素前面
直到前面的元素不满足要求，记录插入位置。
先拿出来 再比较插入
*/
 
void InsertSort(int a[], int len)
{
	int i, j, k; 
	int tmp;
	for (i = 1; i < len; i++)	{ 
		k = i;			//待插入元素位置
		tmp = a[k];	    //先拿出来
 
		for (j = i - 1; (j >= 0) && (a[j] > tmp); j--){
			a[j + 1] = a[j];			//只要大，则元素后移
			k = j;						//记录移动的位置
		} 
		a[k] = tmp;		//元素插入 
	} 
}
~~~



### 3.4 算法分析

插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

## 4、希尔排序（Shell Sort）

1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

### 4.1 算法描述

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；

按增量序列个数k，对序列进行k 趟排序；

每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 4.2 动图演示

![2019061123264652](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322230402.gif)

### 4.3 代码实现

~~~cpp
//核心思想还是使用插入排序算法
//通过分组，让数据在小规模内有序，减小递归增量使得整体有序
 
void ShellSort(int a[], int len)
{
	int i, j, k, tmp;
	int gap = len;
 
	do{	
		//gap的选择可以有多中方案，如gap = gap/2,这里使用的是业界统一实验平均情况最好的，收敛为1
		gap = gap / 3 + 1;
		for (i = gap; i < len; i += gap)  //分成len/gap组
		{
			//每组使用插入排序
			k = i;
			tmp = a[k];
			for (j = i - gap; (j >= 0) && (a[j] > tmp); j -= gap){
				a[j + gap] = a[j];
				k = j;
			}
			a[k] = tmp; 
		}
	} while (gap > 1);
 
}
~~~



### 4.4 算法分析

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　

## 5、归并排序（Merge Sort）

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

### 5.1 算法描述

把长度为n的输入序列分成两个长度为n/2的子序列；

对这两个子序列分别采用归并排序；

将两个排序好的子序列合并成一个最终的排序序列。

### 5.2 动图演示

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322230512.gif)

### 5.3 代码实现

~~~cpp
//归并排序
/*
使用分治思想：
假设两个子数组是有序的，将其按照有序序列合并，合并组成新的有序数组，再与其他部分合并
*/
void merge(int arr[], int low, int mid, int high, int temp[])
{
    int i = low;         //左子数组开始位置
    int j = mid + 1;    //右子数组开始位置
    int t = 0;          //临时空间指针
    while (i <= mid && j <= high)
    {
        if (arr[i] < arr[j])
            temp[t++] = arr[i++];
        else
            temp[t++] = arr[j++];
    }
    //将左边剩余元素填充进temp中
    while (i <= mid)
        temp[t++] = arr[i++];
    //将右边子数组剩余部分填充到temp中
    while (j <= high)
        temp[t++] = arr[j++];
 
    //将融合后的数据拷贝到原来的数据对应的子空间中
    t = 0;
    while (low <= high)
    {
        arr[low++] = temp[t++];
    }
    
}
void mergeSort(int arr[], int low, int high, int temp[])
{
    if (low < high)             //只有low==high为一个元素的时候不用再细分自分组，融合
    {
        int mid = low + (hi - lo)/2;
        //左子数组融合排序
        mergeSort(arr, low, mid, temp);
        //右子数组融合排序
        mergeSort(arr, mid + 1, high, temp);
        //已经排序好的子数组有序融合
        merge(arr, low, mid, high, temp);
    }
 
}
~~~



### 5.4 算法分析

归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

## 6、快速排序（Quick Sort）

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

### 6.1 算法描述

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

从数列中挑出一个元素，称为 “基准”（pivot）；

重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 6.2 动图演示

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322230619.gif)

### 6.3 代码实现

~~~cpp
//快速排序：
/*
选择一个基准，将基准移动到数据中间，使得左边的数据都小于基准，右边的数都大于基准
递归划分，当数据元素等于1个的就是一个的时候就是有序的了
*/
int partition(vector<int>& nums, int lo, int hi){
    swap(nums[lo], nums[lo + rand() % (hi - lo)]);//随机交换
    int pivot = nums[lo];//经过以上交换，等效于随机选取轴点
    hi--;//从[)变[]
    while(lo < hi){//从两端交替向中间扫描，彼此靠拢
        while(lo < hi && pivot <= nums[hi]) hi--;//向左拓展G 
        nums[lo] = nums[hi];//凡小于轴点，归入L
        while(lo < hi && nums[lo] <= pivot) lo++;//向右拓展L 
        nums[hi] = nums[lo];//凡大于轴点，归入G
    }//assert: lo == hi
    nums[lo] = pivot;//候选轴点归位
    return lo;
}
//递归划分，当划分到一个元素的时候，子数组就是有序的
void QuickSort(vector<int>& nums, int lo, int hi)//[lo,hi)
{
    if (hi-lo < 2) return;
    int mi = partition(nums, lo, hi);
    //递归划分划分左右子数组，让左右子数组有序
    QuickSort(nums, low, mi);
    QuickSort(nums, mi+1, high);
}

//------------------------------
//迭代实现
typedef struct _sortPair {
    int begin;
    int end;
} SORT_PAIR;

void sort(vector<int> &arr, int begin, int end) {
    if ((end - begin) < 2)//元素个数小于2,直接退出
        return;
    stack<SORT_PAIR> s;
    s.push(SORT_PAIR { begin, end });
    int sBegin=0;
    int sEnd=0;
    int pivot=0;
    while (s.size() != 0) {
        sBegin = s.top().begin;
        sEnd = s.top().end;
        pivot = partition(arr, sBegin, sEnd);//确定轴点元素位置
        s.pop();//弹出栈顶元素
        if ((pivot - sBegin) >= 2) {//元素个数大于等于2,才需要进行排序
            s.push(SORT_PAIR { sBegin, pivot });
        }
        if ((sEnd - pivot - 1 >= 2)) {//元素个数大于等于2才需要进行排序
            s.push(SORT_PAIR { pivot + 1, sEnd });
        }
    }
}
~~~



## 7、堆排序（Heap Sort）

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

### 7.1 算法描述

堆的性质：

1. 堆是一个完全二叉树，
2. 大顶堆在父节点的值大于子节点的值

堆通过线性表组织，父节点位置，和子节点位置索引有如下关系。

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322230728.png)

堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

### 7.2 动图演示

排序动画过程解释

1. 首先，将所有的数字存储在堆中
2. 按大顶堆构建堆，其中大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序
3. 在这里数字 5 先入堆
4. 数字 2 入堆
5. 数字 7 入堆， 7 此时是最后一个节点，与最后一个非叶子节点（也就是数字 5 ）进行比较，由于 7 大于 5 ，所以 7 和 5 交互
6. 按照上述的操作将所有数字入堆，然后从左到右，从上到下进行调整，构造出大顶堆
7. 入堆完成之后，将堆顶元素取出，将末尾元素置于堆顶，重新调整结构，使其满足堆定义
8. 堆顶元素数字 7 取出，末尾元素数字 4 置于堆顶，为了维护好大顶堆的定义，最后一个非叶子节点数字 5 与 4 比较，而后交换两个数字的位置
9. 反复执行调整+交换步骤，直到整个序列有序


​    ![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322231038.gif)



### 7.3 代码实现

~~~cpp
void swap(int arr[], int i, int j)
{
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
 
void heapify(int tree[], int n, int p)
/*
n表示树的节点个数
p表示要处理的当前节点的下标
该函数的功能是：面对一个仅有节点p为，不符合堆的性质的情况。如果在节点p插入一个新元素，插入比其子节点小的数，就破坏了堆的性质（父节点大于子节点），因此需要对堆进行调整：
调整的思路是如果：
    如果子节点比父节点大，则将其与子节点交换，使得父节点位置满足堆的性质，但是由于交换可能会破坏子节点的堆的性质，因此要递归地对子节点进行堆化
    因为是递归，所以要考虑递归的出口，当节点p达到最后一个叶子节点为止
*/
{
    //递归出口
    if (p >= n)return;          //到达最后一个叶子节点
    //计算左右节点的索引，完全二叉树满足的性质
    int c1 = 2 * p + 1;
    int c2 = 2 * p + 2;
    int max =-1;
    //判断父节点和左右孩子节点中的最大值
    if (c1 < n && tree[c1] > tree[p])
        max = c1;
    if (c2<n && tree[c2] > tree[p])   //c1,c2小于n防止叶子节点c1,c2不满足而越界
        if(max = !-1 && tree[c2]>tree[c1])  //将子结点中最大的那个索引给max
             max=c2;
 
    if (max != -1)    //交换,叶就是说子树不满足堆父大于子的情况，交换，由于交换改变了子树的父节点，因此需要对子树要调整
    {
        swap(tree, max, p);     
        heapify(tree, n, max);//同时对特的子树叶同时做一个heapify
    }
    
}
void build_heap(int tree[], int n)
/*
面对对于一个完全无序的数组，如何构建出一个堆：
思路：从最后一个节点的父节点开始做heapfy，直到根节点，就可以将无序数组组织成堆的形式
*/
 
{ 
     
    int last_node = n - 1;
    int parent = (last_node-1) / 2;     //父节点的位置计算
    for (int i = parent; i >= 0; i--)
    {
        heapify(tree, n, i);
    }
    return;
}
 
 
/*
堆排序：
堆排序将问题分解成了2个步骤：
先建立一个堆，在依据堆顶为最大值的性质，循环抽出堆顶最大值交换到堆的末尾位置，有序序列，由于抽出最大值破坏了堆的性质，因此要重新heapify
而在建立堆的过程中，首先面临的是一堆无序的数，需要从最后一个节点的父节点开始heapify，才能使得整个数组变成堆，其中heapify的过程就是递归将调整父节点子节点的过程
*/
 
 
void heap_sort(int tree[], int n)
{
    //先建立堆
    build_heap(tree, n);
    //由于堆顶总是放的是最大值，因此我们将堆顶元素与堆的最后一个元素做交换
    //做交换后，前面的n-1个数的堆的性质被破坏，重新做一个heapify
    for (int i = n - 1; i >= 0; i--)        //从最后一个元素开始交换
    {
        swap(tree, i, 0);
        heapify(tree, i, 0);     //i==n-1，前面的n-1个元素构成的堆被破坏，重新从堆顶heapify,
    }
}
~~~



## 8、计数排序（Counting Sort）

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序O（n），计数排序要求输入的数据必须是有确定范围的整数。（直方图统计，再按照顺序扔出来）

### 8.1 算法描述

1. 找出待排序的数组中最大和最小的元素；
2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
4. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

### 8.2 动图演示

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322231148.gif)

### 8.3 代码实现



~~~cpp
void countingSort(vector<int>& arr, int maxValue=100) {
	 
	vector<int>bucket(maxValue + 1, 0);
	int sortedIndex = 0;
	int arrLen = arr.size();
	int bucketLen = maxValue + 1; 
	for (int  i = 0; i < arrLen; i++) {
		if (!bucket[arr[i]]) {
			bucket[arr[i]] = 0;
		}
		bucket[arr[i]]++;
	}
 
	for (int j = 0; j < bucketLen; j++) {
		while (bucket[j] > 0) {
			arr[sortedIndex++] = j;
			bucket[j]--;
		}
	}
 
	return;
}
~~~

### 8.4 算法分析

计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

## 9、桶排序（Bucket Sort）

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

### 9.1 算法描述

1. 设置一个定量的数组当作空桶；
2. 遍历输入数据，并且把数据一个一个放到对应的桶里去；
3. 对每个不是空的桶进行排序；
4. 从不是空的桶里把排好序的数据拼接起来。 

### 9.2 图片演示

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322231325.gif)

排序动画过程解释

1. 首先，设置固定数量的空桶，在这里为了方便演示，设置桶的数量为 5 个空桶
2. 遍历整个数列，找到最大值为 56 ，最小值为 2 ，每个桶的范围为 （ 56 - 2 + 1 ）/ 5 = 11
3. 再次遍历整个数列，按照公式 floor((数字 – 最小值) / 11) 将数字放到对应的桶中
4. 比如，数字 7 代入公式 floor (( 7 – 2 ) / 11 ) = 0 放入 0 号桶
5. 数字 12 代入公式 floor((12 – 2) / 11) = 0 放入 0 号桶
6. 数字 56 代入公式 floor((56 – 2) / 11) = 4 放入 4 号桶
7. 当向同一个索引的桶，第二次插入数据时，判断桶中已存在的数字与新插入数字的大小，按照左到右，从小到大的顺序插入（可以使用前面讲解的插入排序）实现
8. 比如，插入数字 19 时， 1 号桶中已经有数字 23 ，在这里使用插入排序，让 19 排在 23 前面
9. 遍历完整个数列后，合并非空的桶，按从左到右的顺序合并 0 ，1 ，2 ，3 ，4 桶。
10. 这样就完成了 桶排序

### 9.3 代码实现

~~~cpp
//每个桶里面使用冒泡排序（也可使用其他排序算法）
void BubbleSort(vector<int>& arr)
{
	int tmp; 
	for (int i = 0; i < arr.size(); i++)
	{
		//内存循环两两比较，大则交换，最后的结果是总有一个达到最后,所以下一次循环就只有遍历n-1个 
		for (int j = 0; j < arr.size() - i - 1; j++)
		{
			if (arr[j]>arr[j + 1])
			{
				tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
}
 
 
void bucketSort(vector<int>& arr, int  bucketSize=5) {
	if (arr.size() == 0) {
		return ;
	} 
	int  i; 
	int minValue = arr[0]; 
	int  maxValue = arr[0]; 
	for (i = 1; i < arr.size(); i++) { 
		if (arr[i] < minValue) {
			minValue = arr[i];			// 输入数据的最小值
		}
		else if (arr[i] > maxValue) {
			maxValue = arr[i];			// 输入数据的最大值
		}
 
	} 
	int bucketCount = int((maxValue - minValue) / bucketSize) + 1;			//根据最大最小计算桶的个数
	vector<vector<int>>buckets(bucketCount,vector<int>());  
 
	// 利用映射函数将数据分配到各个桶中 
	for (i = 0; i < arr.size(); i++) {
		int idx = int((arr[i] - minValue) / bucketSize);
		buckets[idx].push_back(arr[i]); 
	} 
	 
	arr.clear();  
	for (i = 0; i < buckets.size(); i++) { 
		BubbleSort(buckets[i]);					// 对每个桶进行排序，这里使用了冒泡排序，可以用上面的任意一种排序代替
		for (int j = 0; j < buckets[i].size(); j++) { 
			arr.push_back(buckets[i][j]); 
		} 
	} 
	return ; 
}
~~~



### 9.4 算法分析

桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 

## 10、基数排序（Radix Sort）

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。

有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。

最后的次序就是高优先级中更高的在前，高优先级相同时低优先级高的在前。

### 10.1 算法描述

1. 取得数组中的最大数，并取得位数；
2. arr为原始数组，从最低位开始取每个位组成radix数组；
3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

### 10.2 动图演示

![img](https://gitee.com/Raymond-Z/typora/raw/master/image/20210322231424.gif)

从一排全黑的数字开始：

1. 先排列按照个位数的大小，将数字分配到不同的桶里，这一遍分完了，虽然数据依然是乱序，但是我们可以看到如果这些数字只有个位数，当 收集的时候可以发现只要仅有个位数的数字已经是有序的了
2. 同理再排列十位数，再次收集的时候，只要是仅有两位数的数字已经是有序的了

### 10.3 代码实现

~~~cpp
/*
 * 获取数组a中最大值
 *
 * 参数说明：
 *     a -- 数组
 *     n -- 数组长度
 */
int get_max(int a[], int n)
{
    int i, max;
 
    max = a[0];
    for (i = 1; i < n; i++)
        if (a[i] > max)
            max = a[i];
    return max;
}
 
/*
 * 对数组按照"某个位数"进行排序(桶排序)
 *
 * 参数说明：
 *     a -- 数组
 *     n -- 数组长度
 *     exp -- 指数。对数组a按照该指数进行排序。
 *
 * 例如，对于数组a={50, 3, 542, 745, 2014, 154, 63, 616}；
 *    (01) 当exp=1表示按照"个位"对数组a进行排序
 *    (02) 当exp=10表示按照"十位"对数组a进行排序
 *    (03) 当exp=100表示按照"百位"对数组a进行排序
 *    ...
 */
void count_sort(int a[], int n, int exp)
{
    int output[n];             // 存储"被排序数据"的临时数组
    int i, buckets[10] = {0};
 
    // 将数据出现的次数存储在buckets[]中
    for (i = 0; i < n; i++)
        buckets[ (a[i]/exp)%10 ]++;
 
    // 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。
    for (i = 1; i < 10; i++)
        buckets[i] += buckets[i - 1];
 
    // 将数据存储到临时数组output[]中
    for (i = n - 1; i >= 0; i--)
    {
        output[buckets[ (a[i]/exp)%10 ] - 1] = a[i];
        buckets[ (a[i]/exp)%10 ]--;
    }
 
    // 将排序好的数据赋值给a[]
    for (i = 0; i < n; i++)
        a[i] = output[i];
}
 
/*
 * 基数排序
 *
 * 参数说明：
 *     a -- 数组
 *     n -- 数组长度
 */
void radix_sort(int a[], int n)
{
    int exp;    // 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；...
    int max = get_max(a, n);    // 数组a中的最大值
 
    // 从个位开始，对数组a按"指数"进行排序
    for (exp = 1; max/exp > 0; exp *= 10)
        count_sort(a, n, exp);
}
~~~

### 10.4 算法分析

基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。

基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。